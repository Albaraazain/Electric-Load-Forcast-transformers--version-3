{
    "sourceFile": "data_loading/base/base_dataset.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1733003949084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733061971744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,18 @@\n     one_hot_time_variables: bool\r\n     normalize_data: bool = False  # Add with default False\r\n     scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n     time_series_scaler: Any = None  # Add to store scaler instance\r\n+    \r\n+    # Add time resolution configuration\r\n+    time_resolution_minutes: int = 15\r\n+    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n+    \r\n+    def __post_init__(self):\r\n+        # Add validation\r\n+        if 60 % self.time_resolution_minutes != 0:\r\n+            raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n+        self.points_per_hour = 60 // self.time_resolution_minutes\r\n \r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n"
                },
                {
                    "date": 1733066459147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n-# data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass\r\n-from typing import Tuple, Any, Optional\r\n+from typing import Tuple, Any, Optional, List\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n from sklearn.preprocessing import StandardScaler\r\n+import holidays\r\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n@@ -19,55 +19,106 @@\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    normalize_data: bool = False  # Add with default False\r\n-    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n-    time_series_scaler: Any = None  # Add to store scaler instance\r\n-    \r\n-    # Add time resolution configuration\r\n+    normalize_data: bool = False\r\n+    scaling_method: str = \"standard\"\r\n+    time_series_scaler: Any = None\r\n     time_resolution_minutes: int = 15\r\n-    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n+    points_per_hour: int = 4\r\n+    add_time_features: bool = True\r\n+    add_holiday_features: bool = True\r\n+    add_weather_features: bool = False\r\n+    weather_variables: Optional[List[str]] = None\r\n     \r\n     def __post_init__(self):\r\n-        # Add validation\r\n         if 60 % self.time_resolution_minutes != 0:\r\n             raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n         self.points_per_hour = 60 // self.time_resolution_minutes\r\n+        if self.add_weather_features and not self.weather_variables:\r\n+            self.weather_variables = [\"temperature\", \"humidity\", \"wind_speed\"]\r\n \r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n-        self._df = df\r\n+        self._df = df.copy()\r\n         self.config = config\r\n-        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n-        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n-        self.time_labels: Optional[np.ndarray] = None\r\n-        self.rows: Optional[torch.Tensor] = None\r\n+        self.prepared_time_series_input = None\r\n+        self.prepared_time_series_target = None\r\n+        self.time_labels = None\r\n+        self.rows = None\r\n+        self._prepare_features()\r\n \r\n+    def _add_cyclical_features(self) -> None:\r\n+        \"\"\"Add cyclical time features.\"\"\"\r\n+        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n+        \r\n+        # Hour of day\r\n+        self._df['hour_sin'] = np.sin(2 * np.pi * timestamp.dt.hour / 24)\r\n+        self._df['hour_cos'] = np.cos(2 * np.pi * timestamp.dt.hour / 24)\r\n+        \r\n+        # Day of week\r\n+        self._df['dow_sin'] = np.sin(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n\\ No newline at end of file\n+        self._df['dow_cos'] = np.cos(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n+        \r\n+        # Month\r\n+        self._df['month_sin'] = np.sin(2 * np.pi * timestamp.dt.month / 12)\r\n+        self._df['month_cos'] = np.cos(2 * np.pi * timestamp.dt.month / 12)\r\n+\r\n+    def _add_calendar_features(self) -> None:\r\n+        \"\"\"Add holiday and weekend indicators.\"\"\"\r\n+        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n+        us_holidays = holidays.US()\r\n+        \r\n+        self._df['is_holiday'] = timestamp.map(lambda x: x in us_holidays).astype(int)\r\n+        self._df['is_weekend'] = timestamp.dt.dayofweek.isin([5, 6]).astype(int)\r\n+\r\n+    def _prepare_features(self) -> None:\r\n+        \"\"\"Prepare all features based on configuration.\"\"\"\r\n+        if self.config.add_time_features:\r\n+            self._add_cyclical_features()\r\n+            \r\n+        if self.config.add_holiday_features:\r\n+            self._add_calendar_features()\r\n+            \r\n+        if self.config.add_weather_features and self.config.weather_variables:\r\n+            missing_cols = [col for col in self.config.weather_variables \r\n+                          if col not in self._df.columns]\r\n+            if missing_cols:\r\n+                raise ValueError(f\"Weather features {missing_cols} not found in dataset\")\r\n+\r\n+        if self.config.normalize_data:\r\n+            self._normalize_features()\r\n+\r\n+    def _normalize_features(self) -> None:\r\n+        \"\"\"Normalize features using the configured scaler.\"\"\"\r\n+        if self.config.time_series_scaler is None:\r\n+            self.config.time_series_scaler = StandardScaler()\r\n+            \r\n+        features = [col for col in self._df.columns \r\n+                   if col not in [self.config.time_variable]]\r\n+        \r\n+        if self.config.is_training_set:\r\n+            self._df[features] = self.config.time_series_scaler.fit_transform(self._df[features])\r\n+        else:\r\n+            self._df[features] = self.config.time_series_scaler.transform(self._df[features])\r\n+\r\n     @abstractmethod\r\n     def _prepare_time_series_data(self) -> None:\r\n-        \"\"\"Prepare time series data for model input\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __len__(self) -> int:\r\n-        \"\"\"Return the number of items in the dataset\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n-        \"\"\"Get a data item by index\"\"\"\r\n         pass\r\n \r\n     def get_number_of_input_features(self) -> int:\r\n-        \"\"\"Return number of input features\"\"\"\r\n-        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n-            return self.prepared_time_series_input.shape[1]\r\n-        return 0\r\n+        return (self.prepared_time_series_input.shape[1] \r\n+                if self.prepared_time_series_input is not None else 0)\r\n \r\n     def get_number_of_target_variables(self) -> int:\r\n-        \"\"\"Return number of target variables\"\"\"\r\n-        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n-            return self.prepared_time_series_target.shape[1]\r\n-        return 0\n+        return (self.prepared_time_series_target.shape[1] \r\n+                if self.prepared_time_series_target is not None else 0)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733066556089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n+# data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass\r\n-from typing import Tuple, Any, Optional, List\r\n+from typing import Tuple, Any, Optional\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n from sklearn.preprocessing import StandardScaler\r\n-import holidays\r\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n@@ -19,106 +19,55 @@\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    normalize_data: bool = False\r\n-    scaling_method: str = \"standard\"\r\n-    time_series_scaler: Any = None\r\n+    normalize_data: bool = False  # Add with default False\r\n+    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n+    time_series_scaler: Any = None  # Add to store scaler instance\r\n+    \r\n+    # Add time resolution configuration\r\n     time_resolution_minutes: int = 15\r\n-    points_per_hour: int = 4\r\n-    add_time_features: bool = True\r\n-    add_holiday_features: bool = True\r\n-    add_weather_features: bool = False\r\n-    weather_variables: Optional[List[str]] = None\r\n+    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n     \r\n     def __post_init__(self):\r\n+        # Add validation\r\n         if 60 % self.time_resolution_minutes != 0:\r\n             raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n         self.points_per_hour = 60 // self.time_resolution_minutes\r\n-        if self.add_weather_features and not self.weather_variables:\r\n-            self.weather_variables = [\"temperature\", \"humidity\", \"wind_speed\"]\r\n \r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n-        self._df = df.copy()\r\n+        self._df = df\r\n         self.config = config\r\n-        self.prepared_time_series_input = None\r\n-        self.prepared_time_series_target = None\r\n-        self.time_labels = None\r\n-        self.rows = None\r\n-        self._prepare_features()\r\n+        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n+        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n+        self.time_labels: Optional[np.ndarray] = None\r\n+        self.rows: Optional[torch.Tensor] = None\r\n \r\n-    def _add_cyclical_features(self) -> None:\r\n-        \"\"\"Add cyclical time features.\"\"\"\r\n-        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n-        \r\n-        # Hour of day\r\n-        self._df['hour_sin'] = np.sin(2 * np.pi * timestamp.dt.hour / 24)\r\n-        self._df['hour_cos'] = np.cos(2 * np.pi * timestamp.dt.hour / 24)\r\n-        \r\n-        # Day of week\r\n-        self._df['dow_sin'] = np.sin(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n-        self._df['dow_cos'] = np.cos(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n-        \r\n-        # Month\r\n-        self._df['month_sin'] = np.sin(2 * np.pi * timestamp.dt.month / 12)\r\n-        self._df['month_cos'] = np.cos(2 * np.pi * timestamp.dt.month / 12)\r\n-\r\n-    def _add_calendar_features(self) -> None:\r\n-        \"\"\"Add holiday and weekend indicators.\"\"\"\r\n-        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n-        us_holidays = holidays.US()\r\n-        \r\n-        self._df['is_holiday'] = timestamp.map(lambda x: x in us_holidays).astype(int)\r\n-        self._df['is_weekend'] = timestamp.dt.dayofweek.isin([5, 6]).astype(int)\r\n-\r\n-    def _prepare_features(self) -> None:\r\n-        \"\"\"Prepare all features based on configuration.\"\"\"\r\n-        if self.config.add_time_features:\r\n-            self._add_cyclical_features()\r\n-            \r\n-        if self.config.add_holiday_features:\r\n-            self._add_calendar_features()\r\n-            \r\n-        if self.config.add_weather_features and self.config.weather_variables:\r\n-            missing_cols = [col for col in self.config.weather_variables \r\n-                          if col not in self._df.columns]\r\n-            if missing_cols:\r\n-                raise ValueError(f\"Weather features {missing_cols} not found in dataset\")\r\n-\r\n-        if self.config.normalize_data:\r\n-            self._normalize_features()\r\n-\r\n-    def _normalize_features(self) -> None:\r\n-        \"\"\"Normalize features using the configured scaler.\"\"\"\r\n-        if self.config.time_series_scaler is None:\r\n-            self.config.time_series_scaler = StandardScaler()\r\n-            \r\n-        features = [col for col in self._df.columns \r\n-                   if col not in [self.config.time_variable]]\r\n-        \r\n-        if self.config.is_training_set:\r\n-            self._df[features] = self.config.time_series_scaler.fit_transform(self._df[features])\r\n-        else:\r\n-            self._df[features] = self.config.time_series_scaler.transform(self._df[features])\r\n-\r\n     @abstractmethod\r\n     def _prepare_time_series_data(self) -> None:\r\n+        \"\"\"Prepare time series data for model input\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __len__(self) -> int:\r\n\\ No newline at end of file\n+        \"\"\"Return the number of items in the dataset\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n+        \"\"\"Get a data item by index\"\"\"\r\n         pass\r\n \r\n     def get_number_of_input_features(self) -> int:\r\n-        return (self.prepared_time_series_input.shape[1] \r\n-                if self.prepared_time_series_input is not None else 0)\r\n+        \"\"\"Return number of input features\"\"\"\r\n+        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n+            return self.prepared_time_series_input.shape[1]\r\n+        return 0\r\n \r\n     def get_number_of_target_variables(self) -> int:\r\n-        return (self.prepared_time_series_target.shape[1] \r\n-                if self.prepared_time_series_target is not None else 0)\n+        \"\"\"Return number of target variables\"\"\"\r\n+        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n+            return self.prepared_time_series_target.shape[1]\r\n+        return 0\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733066721997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n-# data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n-from dataclasses import dataclass\r\n-from typing import Tuple, Any, Optional\r\n+from dataclasses import dataclass, field\r\n+from typing import Tuple, Any, Optional, Dict\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n@@ -10,8 +9,9 @@\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n+    # Required parameters\r\n     time_variable: str\r\n     target_variable: str\r\n     time_series_window_in_hours: int\r\n     forecasting_horizon_in_hours: int\r\n@@ -19,22 +19,75 @@\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    normalize_data: bool = False  # Add with default False\r\n-    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n-    time_series_scaler: Any = None  # Add to store scaler instance\r\n-    \r\n-    # Add time resolution configuration\r\n+\r\n+    # Data processing parameters with defaults\r\n+    normalize_data: bool = False\r\n+    scaling_method: str = \"standard\"\r\n+    time_series_scaler: Any = None\r\n+\r\n+    # Time resolution configuration\r\n     time_resolution_minutes: int = 15\r\n-    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n-    \r\n+    points_per_hour: int = field(init=False)\r\n+\r\n+    # Feature generation flags\r\n+    add_time_features: bool = True\r\n+    add_holiday_features: bool = False\r\n+    add_weather_features: bool = False\r\n+\r\n+    # Cache for computed values\r\n+    _window_size: Optional[int] = field(init=False, default=None)\r\n+    _horizon_size: Optional[int] = field(init=False, default=None)\r\n+\r\n     def __post_init__(self):\r\n-        # Add validation\r\n+        \"\"\"Validate configuration and compute derived values.\"\"\"\r\n+        # Validate time resolution\r\n         if 60 % self.time_resolution_minutes != 0:\r\n             raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n+        \r\n+        # Set points per hour\r\n         self.points_per_hour = 60 // self.time_resolution_minutes\r\n \r\n+        # Initialize scaler if needed\r\n+        if self.normalize_data and self.time_series_scaler is None:\r\n+            self.time_series_scaler = StandardScaler() if self.scaling_method == \"standard\" else None\r\n+\r\n+        # Compute and cache window sizes in data points\r\n+        self._window_size = self.time_series_window_in_hours * self.points_per_hour\r\n+        self._horizon_size = self.forecasting_horizon_in_hours * self.points_per_hour\r\n+\r\n+    @property\r\n+    def window_size(self) -> int:\r\n+        \"\"\"Get window size in number of data points.\"\"\"\r\n+        return self._window_size if self._window_size is not None else self.time_series_window_in_hours * self.points_per_hour\r\n+\r\n+    @property\r\n+    def horizon_size(self) -> int:\r\n+        \"\"\"Get forecast horizon in number of data points.\"\"\"\r\n+        return self._horizon_size if self._horizon_size is not None else self.forecasting_horizon_in_hours * self.points_per_hour\r\n+\r\n+    def to_dict(self) -> Dict[str, Any]:\r\n+        \"\"\"Convert config to dictionary for serialization.\"\"\"\r\n+        return {\r\n+            'time_variable': self.time_variable,\r\n+            'target_variable': self.target_variable,\r\n+            'time_series_window_in_hours': self.time_series_window_in_hours,\r\n+            'forecasting_horizon_in_hours': self.forecasting_horizon_in_hours,\r\n+            'is_single_time_point_prediction': self.is_single_time_point_prediction,\r\n+            'include_time_information': self.include_time_information,\r\n+            'is_training_set': self.is_training_set,\r\n+            'labels_count': self.labels_count,\r\n+            'one_hot_time_variables': self.one_hot_time_variables,\r\n+            'normalize_data': self.normalize_data,\r\n+            'scaling_method': self.scaling_method,\r\n+            'time_resolution_minutes': self.time_resolution_minutes,\r\n+            'add_time_features': self.add_time_features,\r\n+            'add_holiday_features': self.add_holiday_features,\r\n+            'add_weather_features': self.add_weather_features\r\n+        }\r\n+\r\n+\r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n@@ -69,5 +122,15 @@\n     def get_number_of_target_variables(self) -> int:\r\n         \"\"\"Return number of target variables\"\"\"\r\n         if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n             return self.prepared_time_series_target.shape[1]\r\n-        return 0\n\\ No newline at end of file\n+        return 0\r\n+\r\n+    def _validate_data(self) -> None:\r\n+        \"\"\"Validate input data format and completeness.\"\"\"\r\n+        if self._df is None or self._df.empty:\r\n+            raise ValueError(\"Input DataFrame is empty or None\")\r\n+\r\n+        required_columns = [self.config.time_variable, self.config.target_variable]\r\n+        missing_columns = [col for col in required_columns if col not in self._df.columns]\r\n+        if missing_columns:\r\n+            raise ValueError(f\"Missing required columns: {missing_columns}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733066758496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+# path: data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass, field\r\n from typing import Tuple, Any, Optional, Dict\r\n import torch\r\n"
                }
            ],
            "date": 1733003949084,
            "name": "Commit-0",
            "content": "# data_loading/base/base_dataset.py\r\nfrom abc import ABC, abstractmethod\r\nfrom dataclasses import dataclass\r\nfrom typing import Tuple, Any, Optional\r\nimport torch\r\nfrom torch.utils.data import Dataset\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom sklearn.preprocessing import StandardScaler\r\n\r\n@dataclass\r\nclass DatasetConfig:\r\n    \"\"\"Configuration for dataset preparation.\"\"\"\r\n    time_variable: str\r\n    target_variable: str\r\n    time_series_window_in_hours: int\r\n    forecasting_horizon_in_hours: int\r\n    is_single_time_point_prediction: bool\r\n    include_time_information: bool\r\n    is_training_set: bool\r\n    labels_count: int\r\n    one_hot_time_variables: bool\r\n    normalize_data: bool = False  # Add with default False\r\n    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n    time_series_scaler: Any = None  # Add to store scaler instance\r\n\r\nclass BaseDataset(ABC, Dataset):\r\n    \"\"\"Base class for all datasets\"\"\"\r\n\r\n    def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n        self._df = df\r\n        self.config = config\r\n        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n        self.time_labels: Optional[np.ndarray] = None\r\n        self.rows: Optional[torch.Tensor] = None\r\n\r\n    @abstractmethod\r\n    def _prepare_time_series_data(self) -> None:\r\n        \"\"\"Prepare time series data for model input\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def __len__(self) -> int:\r\n        \"\"\"Return the number of items in the dataset\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n        \"\"\"Get a data item by index\"\"\"\r\n        pass\r\n\r\n    def get_number_of_input_features(self) -> int:\r\n        \"\"\"Return number of input features\"\"\"\r\n        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n            return self.prepared_time_series_input.shape[1]\r\n        return 0\r\n\r\n    def get_number_of_target_variables(self) -> int:\r\n        \"\"\"Return number of target variables\"\"\"\r\n        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n            return self.prepared_time_series_target.shape[1]\r\n        return 0"
        }
    ]
}