{
    "sourceFile": "data_loading/base/base_dataset.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1733003949084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733061971744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,18 @@\n     one_hot_time_variables: bool\r\n     normalize_data: bool = False  # Add with default False\r\n     scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n     time_series_scaler: Any = None  # Add to store scaler instance\r\n+    \r\n+    # Add time resolution configuration\r\n+    time_resolution_minutes: int = 15\r\n+    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n+    \r\n+    def __post_init__(self):\r\n+        # Add validation\r\n+        if 60 % self.time_resolution_minutes != 0:\r\n+            raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n+        self.points_per_hour = 60 // self.time_resolution_minutes\r\n \r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n"
                },
                {
                    "date": 1733066459147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n-# data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass\r\n-from typing import Tuple, Any, Optional\r\n+from typing import Tuple, Any, Optional, List\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n from sklearn.preprocessing import StandardScaler\r\n+import holidays\r\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n@@ -19,55 +19,106 @@\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    normalize_data: bool = False  # Add with default False\r\n-    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n-    time_series_scaler: Any = None  # Add to store scaler instance\r\n-    \r\n-    # Add time resolution configuration\r\n+    normalize_data: bool = False\r\n+    scaling_method: str = \"standard\"\r\n+    time_series_scaler: Any = None\r\n     time_resolution_minutes: int = 15\r\n-    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n+    points_per_hour: int = 4\r\n+    add_time_features: bool = True\r\n+    add_holiday_features: bool = True\r\n+    add_weather_features: bool = False\r\n+    weather_variables: Optional[List[str]] = None\r\n     \r\n     def __post_init__(self):\r\n-        # Add validation\r\n         if 60 % self.time_resolution_minutes != 0:\r\n             raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n         self.points_per_hour = 60 // self.time_resolution_minutes\r\n+        if self.add_weather_features and not self.weather_variables:\r\n+            self.weather_variables = [\"temperature\", \"humidity\", \"wind_speed\"]\r\n \r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n-        self._df = df\r\n+        self._df = df.copy()\r\n         self.config = config\r\n-        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n-        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n-        self.time_labels: Optional[np.ndarray] = None\r\n-        self.rows: Optional[torch.Tensor] = None\r\n+        self.prepared_time_series_input = None\r\n+        self.prepared_time_series_target = None\r\n+        self.time_labels = None\r\n+        self.rows = None\r\n+        self._prepare_features()\r\n \r\n+    def _add_cyclical_features(self) -> None:\r\n+        \"\"\"Add cyclical time features.\"\"\"\r\n+        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n+        \r\n+        # Hour of day\r\n+        self._df['hour_sin'] = np.sin(2 * np.pi * timestamp.dt.hour / 24)\r\n+        self._df['hour_cos'] = np.cos(2 * np.pi * timestamp.dt.hour / 24)\r\n+        \r\n+        # Day of week\r\n+        self._df['dow_sin'] = np.sin(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n\\ No newline at end of file\n+        self._df['dow_cos'] = np.cos(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n+        \r\n+        # Month\r\n+        self._df['month_sin'] = np.sin(2 * np.pi * timestamp.dt.month / 12)\r\n+        self._df['month_cos'] = np.cos(2 * np.pi * timestamp.dt.month / 12)\r\n+\r\n+    def _add_calendar_features(self) -> None:\r\n+        \"\"\"Add holiday and weekend indicators.\"\"\"\r\n+        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n+        us_holidays = holidays.US()\r\n+        \r\n+        self._df['is_holiday'] = timestamp.map(lambda x: x in us_holidays).astype(int)\r\n+        self._df['is_weekend'] = timestamp.dt.dayofweek.isin([5, 6]).astype(int)\r\n+\r\n+    def _prepare_features(self) -> None:\r\n+        \"\"\"Prepare all features based on configuration.\"\"\"\r\n+        if self.config.add_time_features:\r\n+            self._add_cyclical_features()\r\n+            \r\n+        if self.config.add_holiday_features:\r\n+            self._add_calendar_features()\r\n+            \r\n+        if self.config.add_weather_features and self.config.weather_variables:\r\n+            missing_cols = [col for col in self.config.weather_variables \r\n+                          if col not in self._df.columns]\r\n+            if missing_cols:\r\n+                raise ValueError(f\"Weather features {missing_cols} not found in dataset\")\r\n+\r\n+        if self.config.normalize_data:\r\n+            self._normalize_features()\r\n+\r\n+    def _normalize_features(self) -> None:\r\n+        \"\"\"Normalize features using the configured scaler.\"\"\"\r\n+        if self.config.time_series_scaler is None:\r\n+            self.config.time_series_scaler = StandardScaler()\r\n+            \r\n+        features = [col for col in self._df.columns \r\n+                   if col not in [self.config.time_variable]]\r\n+        \r\n+        if self.config.is_training_set:\r\n+            self._df[features] = self.config.time_series_scaler.fit_transform(self._df[features])\r\n+        else:\r\n+            self._df[features] = self.config.time_series_scaler.transform(self._df[features])\r\n+\r\n     @abstractmethod\r\n     def _prepare_time_series_data(self) -> None:\r\n-        \"\"\"Prepare time series data for model input\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __len__(self) -> int:\r\n-        \"\"\"Return the number of items in the dataset\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n-        \"\"\"Get a data item by index\"\"\"\r\n         pass\r\n \r\n     def get_number_of_input_features(self) -> int:\r\n-        \"\"\"Return number of input features\"\"\"\r\n-        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n-            return self.prepared_time_series_input.shape[1]\r\n-        return 0\r\n+        return (self.prepared_time_series_input.shape[1] \r\n+                if self.prepared_time_series_input is not None else 0)\r\n \r\n     def get_number_of_target_variables(self) -> int:\r\n-        \"\"\"Return number of target variables\"\"\"\r\n-        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n-            return self.prepared_time_series_target.shape[1]\r\n-        return 0\n+        return (self.prepared_time_series_target.shape[1] \r\n+                if self.prepared_time_series_target is not None else 0)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733066556089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n+# data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass\r\n-from typing import Tuple, Any, Optional, List\r\n+from typing import Tuple, Any, Optional\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n from sklearn.preprocessing import StandardScaler\r\n-import holidays\r\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n@@ -19,106 +19,55 @@\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    normalize_data: bool = False\r\n-    scaling_method: str = \"standard\"\r\n-    time_series_scaler: Any = None\r\n+    normalize_data: bool = False  # Add with default False\r\n+    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n+    time_series_scaler: Any = None  # Add to store scaler instance\r\n+    \r\n+    # Add time resolution configuration\r\n     time_resolution_minutes: int = 15\r\n-    points_per_hour: int = 4\r\n-    add_time_features: bool = True\r\n-    add_holiday_features: bool = True\r\n-    add_weather_features: bool = False\r\n-    weather_variables: Optional[List[str]] = None\r\n+    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n     \r\n     def __post_init__(self):\r\n+        # Add validation\r\n         if 60 % self.time_resolution_minutes != 0:\r\n             raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n         self.points_per_hour = 60 // self.time_resolution_minutes\r\n-        if self.add_weather_features and not self.weather_variables:\r\n-            self.weather_variables = [\"temperature\", \"humidity\", \"wind_speed\"]\r\n \r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n-        self._df = df.copy()\r\n+        self._df = df\r\n         self.config = config\r\n-        self.prepared_time_series_input = None\r\n-        self.prepared_time_series_target = None\r\n-        self.time_labels = None\r\n-        self.rows = None\r\n-        self._prepare_features()\r\n+        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n+        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n+        self.time_labels: Optional[np.ndarray] = None\r\n+        self.rows: Optional[torch.Tensor] = None\r\n \r\n-    def _add_cyclical_features(self) -> None:\r\n-        \"\"\"Add cyclical time features.\"\"\"\r\n-        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n-        \r\n-        # Hour of day\r\n-        self._df['hour_sin'] = np.sin(2 * np.pi * timestamp.dt.hour / 24)\r\n-        self._df['hour_cos'] = np.cos(2 * np.pi * timestamp.dt.hour / 24)\r\n-        \r\n-        # Day of week\r\n-        self._df['dow_sin'] = np.sin(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n-        self._df['dow_cos'] = np.cos(2 * np.pi * timestamp.dt.dayofweek / 7)\r\n-        \r\n-        # Month\r\n-        self._df['month_sin'] = np.sin(2 * np.pi * timestamp.dt.month / 12)\r\n-        self._df['month_cos'] = np.cos(2 * np.pi * timestamp.dt.month / 12)\r\n-\r\n-    def _add_calendar_features(self) -> None:\r\n-        \"\"\"Add holiday and weekend indicators.\"\"\"\r\n-        timestamp = pd.to_datetime(self._df[self.config.time_variable])\r\n-        us_holidays = holidays.US()\r\n-        \r\n-        self._df['is_holiday'] = timestamp.map(lambda x: x in us_holidays).astype(int)\r\n-        self._df['is_weekend'] = timestamp.dt.dayofweek.isin([5, 6]).astype(int)\r\n-\r\n-    def _prepare_features(self) -> None:\r\n-        \"\"\"Prepare all features based on configuration.\"\"\"\r\n-        if self.config.add_time_features:\r\n-            self._add_cyclical_features()\r\n-            \r\n-        if self.config.add_holiday_features:\r\n-            self._add_calendar_features()\r\n-            \r\n-        if self.config.add_weather_features and self.config.weather_variables:\r\n-            missing_cols = [col for col in self.config.weather_variables \r\n-                          if col not in self._df.columns]\r\n-            if missing_cols:\r\n-                raise ValueError(f\"Weather features {missing_cols} not found in dataset\")\r\n-\r\n-        if self.config.normalize_data:\r\n-            self._normalize_features()\r\n-\r\n-    def _normalize_features(self) -> None:\r\n-        \"\"\"Normalize features using the configured scaler.\"\"\"\r\n-        if self.config.time_series_scaler is None:\r\n-            self.config.time_series_scaler = StandardScaler()\r\n-            \r\n-        features = [col for col in self._df.columns \r\n-                   if col not in [self.config.time_variable]]\r\n-        \r\n-        if self.config.is_training_set:\r\n-            self._df[features] = self.config.time_series_scaler.fit_transform(self._df[features])\r\n-        else:\r\n-            self._df[features] = self.config.time_series_scaler.transform(self._df[features])\r\n-\r\n     @abstractmethod\r\n     def _prepare_time_series_data(self) -> None:\r\n+        \"\"\"Prepare time series data for model input\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __len__(self) -> int:\r\n\\ No newline at end of file\n+        \"\"\"Return the number of items in the dataset\"\"\"\r\n         pass\r\n \r\n     @abstractmethod\r\n     def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n+        \"\"\"Get a data item by index\"\"\"\r\n         pass\r\n \r\n     def get_number_of_input_features(self) -> int:\r\n-        return (self.prepared_time_series_input.shape[1] \r\n-                if self.prepared_time_series_input is not None else 0)\r\n+        \"\"\"Return number of input features\"\"\"\r\n+        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n+            return self.prepared_time_series_input.shape[1]\r\n+        return 0\r\n \r\n     def get_number_of_target_variables(self) -> int:\r\n-        return (self.prepared_time_series_target.shape[1] \r\n-                if self.prepared_time_series_target is not None else 0)\n+        \"\"\"Return number of target variables\"\"\"\r\n+        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n+            return self.prepared_time_series_target.shape[1]\r\n+        return 0\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733066721997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n-# data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n-from dataclasses import dataclass\r\n-from typing import Tuple, Any, Optional\r\n+from dataclasses import dataclass, field\r\n+from typing import Tuple, Any, Optional, Dict\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n@@ -10,8 +9,9 @@\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n+    # Required parameters\r\n     time_variable: str\r\n     target_variable: str\r\n     time_series_window_in_hours: int\r\n     forecasting_horizon_in_hours: int\r\n@@ -19,22 +19,75 @@\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    normalize_data: bool = False  # Add with default False\r\n-    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n-    time_series_scaler: Any = None  # Add to store scaler instance\r\n-    \r\n-    # Add time resolution configuration\r\n+\r\n+    # Data processing parameters with defaults\r\n+    normalize_data: bool = False\r\n+    scaling_method: str = \"standard\"\r\n+    time_series_scaler: Any = None\r\n+\r\n+    # Time resolution configuration\r\n     time_resolution_minutes: int = 15\r\n-    points_per_hour: int = 4  # Derived from time resolution (60/15)\r\n-    \r\n+    points_per_hour: int = field(init=False)\r\n+\r\n+    # Feature generation flags\r\n+    add_time_features: bool = True\r\n+    add_holiday_features: bool = False\r\n+    add_weather_features: bool = False\r\n+\r\n+    # Cache for computed values\r\n+    _window_size: Optional[int] = field(init=False, default=None)\r\n+    _horizon_size: Optional[int] = field(init=False, default=None)\r\n+\r\n     def __post_init__(self):\r\n-        # Add validation\r\n+        \"\"\"Validate configuration and compute derived values.\"\"\"\r\n+        # Validate time resolution\r\n         if 60 % self.time_resolution_minutes != 0:\r\n             raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n+        \r\n+        # Set points per hour\r\n         self.points_per_hour = 60 // self.time_resolution_minutes\r\n \r\n+        # Initialize scaler if needed\r\n+        if self.normalize_data and self.time_series_scaler is None:\r\n+            self.time_series_scaler = StandardScaler() if self.scaling_method == \"standard\" else None\r\n+\r\n+        # Compute and cache window sizes in data points\r\n+        self._window_size = self.time_series_window_in_hours * self.points_per_hour\r\n+        self._horizon_size = self.forecasting_horizon_in_hours * self.points_per_hour\r\n+\r\n+    @property\r\n+    def window_size(self) -> int:\r\n+        \"\"\"Get window size in number of data points.\"\"\"\r\n+        return self._window_size if self._window_size is not None else self.time_series_window_in_hours * self.points_per_hour\r\n+\r\n+    @property\r\n+    def horizon_size(self) -> int:\r\n+        \"\"\"Get forecast horizon in number of data points.\"\"\"\r\n+        return self._horizon_size if self._horizon_size is not None else self.forecasting_horizon_in_hours * self.points_per_hour\r\n+\r\n+    def to_dict(self) -> Dict[str, Any]:\r\n+        \"\"\"Convert config to dictionary for serialization.\"\"\"\r\n+        return {\r\n+            'time_variable': self.time_variable,\r\n+            'target_variable': self.target_variable,\r\n+            'time_series_window_in_hours': self.time_series_window_in_hours,\r\n+            'forecasting_horizon_in_hours': self.forecasting_horizon_in_hours,\r\n+            'is_single_time_point_prediction': self.is_single_time_point_prediction,\r\n+            'include_time_information': self.include_time_information,\r\n+            'is_training_set': self.is_training_set,\r\n+            'labels_count': self.labels_count,\r\n+            'one_hot_time_variables': self.one_hot_time_variables,\r\n+            'normalize_data': self.normalize_data,\r\n+            'scaling_method': self.scaling_method,\r\n+            'time_resolution_minutes': self.time_resolution_minutes,\r\n+            'add_time_features': self.add_time_features,\r\n+            'add_holiday_features': self.add_holiday_features,\r\n+            'add_weather_features': self.add_weather_features\r\n+        }\r\n+\r\n+\r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n@@ -69,5 +122,15 @@\n     def get_number_of_target_variables(self) -> int:\r\n         \"\"\"Return number of target variables\"\"\"\r\n         if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n             return self.prepared_time_series_target.shape[1]\r\n-        return 0\n\\ No newline at end of file\n+        return 0\r\n+\r\n+    def _validate_data(self) -> None:\r\n+        \"\"\"Validate input data format and completeness.\"\"\"\r\n+        if self._df is None or self._df.empty:\r\n+            raise ValueError(\"Input DataFrame is empty or None\")\r\n+\r\n+        required_columns = [self.config.time_variable, self.config.target_variable]\r\n+        missing_columns = [col for col in required_columns if col not in self._df.columns]\r\n+        if missing_columns:\r\n+            raise ValueError(f\"Missing required columns: {missing_columns}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733066758496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+# path: data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass, field\r\n from typing import Tuple, Any, Optional, Dict\r\n import torch\r\n"
                },
                {
                    "date": 1733132775745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,13 @@\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n     # Required parameters\r\n     time_variable: str\r\n     target_variable: str\r\n+    \r\n+    input_resolution_minutes: int   # Resolution of source data (e.g., 15 for 15-min data)\r\n+    forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n+\r\n+    \r\n     time_series_window_in_hours: int\r\n     forecasting_horizon_in_hours: int\r\n     is_single_time_point_prediction: bool\r\n     include_time_information: bool\r\n"
                },
                {
                    "date": 1733132790342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,11 @@\n     \r\n     input_resolution_minutes: int   # Resolution of source data (e.g., 15 for 15-min data)\r\n     forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n \r\n-    \r\n+    lookback_periods: int      # How many periods to look back\r\n+    forecast_periods: int      # How many periods to predict\r\n+\r\n     time_series_window_in_hours: int\r\n     forecasting_horizon_in_hours: int\r\n     is_single_time_point_prediction: bool\r\n     include_time_information: bool\r\n"
                },
                {
                    "date": 1733132964422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,10 @@\n import pandas as pd\r\n import numpy as np\r\n from sklearn.preprocessing import StandardScaler\r\n \r\n+from data_loading.types.interval_types import IntervalConfig\r\n+\r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n     # Required parameters\r\n@@ -19,51 +21,60 @@\n     forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n \r\n     lookback_periods: int      # How many periods to look back\r\n     forecast_periods: int      # How many periods to predict\r\n-\r\n-    time_series_window_in_hours: int\r\n-    forecasting_horizon_in_hours: int\r\n+    \r\n     is_single_time_point_prediction: bool\r\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-\r\n+    \r\n     # Data processing parameters with defaults\r\n     normalize_data: bool = False\r\n     scaling_method: str = \"standard\"\r\n     time_series_scaler: Any = None\r\n-\r\n-    # Time resolution configuration\r\n-    time_resolution_minutes: int = 15\r\n-    points_per_hour: int = field(init=False)\r\n-\r\n+    \r\n     # Feature generation flags\r\n     add_time_features: bool = True\r\n     add_holiday_features: bool = False\r\n     add_weather_features: bool = False\r\n \r\n     # Cache for computed values\r\n     _window_size: Optional[int] = field(init=False, default=None)\r\n     _horizon_size: Optional[int] = field(init=False, default=None)\r\n+    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n \r\n     def __post_init__(self):\r\n         \"\"\"Validate configuration and compute derived values.\"\"\"\r\n-        # Validate time resolution\r\n-        if 60 % self.time_resolution_minutes != 0:\r\n-            raise ValueError(f\"Invalid time resolution: {self.time_resolution_minutes} minutes\")\r\n-        \r\n-        # Set points per hour\r\n-        self.points_per_hour = 60 // self.time_resolution_minutes\r\n+        # Validate input resolution\r\n+        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate forecast resolution\r\n+        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate that forecast resolution is not finer than input resolution\r\n+        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n+            raise ValueError(\r\n+                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n+                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n+            )\r\n \r\n+        # Create interval configuration based on forecast resolution\r\n+        self._interval_config = IntervalConfig(\r\n+            interval_type=self._determine_interval_type(),\r\n+            lookback_periods=self.lookback_periods,\r\n+            forecast_periods=self.forecast_periods\r\n+        )\r\n+\r\n         # Initialize scaler if needed\r\n         if self.normalize_data and self.time_series_scaler is None:\r\n             self.time_series_scaler = StandardScaler() if self.scaling_method == \"standard\" else None\r\n \r\n-        # Compute and cache window sizes in data points\r\n-        self._window_size = self.time_series_window_in_hours * self.points_per_hour\r\n-        self._horizon_size = self.forecasting_horizon_in_hours * self.points_per_hour\r\n+        # Compute window sizes considering both resolutions\r\n+        self._compute_window_sizes()\r\n \r\n     @property\r\n     def window_size(self) -> int:\r\n         \"\"\"Get window size in number of data points.\"\"\"\r\n"
                },
                {
                    "date": 1733133039180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,175 @@\n+# path: data_loading/base/base_dataset.py\r\n+from abc import ABC, abstractmethod\r\n+from dataclasses import dataclass, field\r\n+from typing import Tuple, Any, Optional, Dict\r\n+import torch\r\n+from torch.utils.data import Dataset\r\n+import pandas as pd\r\n+import numpy as np\r\n+from sklearn.preprocessing import StandardScaler\r\n+\r\n+from data_loading.types.interval_types import IntervalConfig\r\n+\r\n+@dataclass\r\n+class DatasetConfig:\r\n+    \"\"\"Configuration for dataset preparation.\"\"\"\r\n+    # Required parameters\r\n+    time_variable: str\r\n+    target_variable: str\r\n+    \r\n+    input_resolution_minutes: int   # Resolution of source data (e.g., 15 for 15-min data)\r\n+    forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n+\r\n+    lookback_periods: int      # How many periods to look back\r\n+    forecast_periods: int      # How many periods to predict\r\n+    \r\n+    is_single_time_point_prediction: bool\r\n+    include_time_information: bool\r\n+    is_training_set: bool\r\n+    labels_count: int\r\n+    one_hot_time_variables: bool\r\n+    \r\n+    # Data processing parameters with defaults\r\n+    normalize_data: bool = False\r\n+    scaling_method: str = \"standard\"\r\n+    time_series_scaler: Any = None\r\n+    \r\n+    # Feature generation flags\r\n+    add_time_features: bool = True\r\n+    add_holiday_features: bool = False\r\n+    add_weather_features: bool = False\r\n+\r\n+    # Cache for computed values\r\n+    _window_size: Optional[int] = field(init=False, default=None)\r\n+    _horizon_size: Optional[int] = field(init=False, default=None)\r\n+    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n+\r\n+    def __post_init__(self):\r\n+        \"\"\"Validate configuration and compute derived values.\"\"\"\r\n+        # Validate input resolution\r\n+        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate forecast resolution\r\n+        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate that forecast resolution is not finer than input resolution\r\n+        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n+            raise ValueError(\r\n+                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n+                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n+            )\r\n+\r\n+        # Create interval configuration based on forecast resolution\r\n+        self._interval_config = IntervalConfig(\r\n+            interval_type=self._determine_interval_type(),\r\n+            lookback_periods=self.lookback_periods,\r\n+            forecast_periods=self.forecast_periods\r\n+        )\r\n+\r\n+        # Initialize scaler if needed\r\n+        if self.normalize_data and self.time_series_scaler is None:\r\n+            self.time_series_scaler = StandardScaler() if self.scaling_method == \"standard\" else None\r\n+\r\n+        # Compute window sizes considering both resolutions\r\n+        self._compute_window_sizes()\r\n+\r\n+    def _determine_interval_type(self) -> TimeInterval:\r\n+        \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n+        resolution = self.forecast_resolution_minutes\r\n+        if resolution <= 15:\r\n+            return TimeInterval.FIFTEEN_MIN\r\n+        elif resolution <= 60:\r\n+            return TimeInterval.HOURLY\r\n+        elif resolution <= 1440:  # 24 hours\r\n+            return TimeInterval.DAILY\r\n+        else:\r\n+            return TimeInterval.MONTHLY\r\n+\r\n+    def _compute_window_sizes(self) -> None:\r\n+        \"\"\"Compute window sizes considering input and forecast resolutions.\"\"\"\r\n+        # Calculate input points based on input resolution\r\n+        input_points_per_period = 60 // self.input_resolution_minutes if self.input_resolution_minutes <= 60 else 1\r\n+        self._window_size = self.lookback_periods * input_points_per_period\r\n+\r\n+        # Calculate output points based on forecast resolution\r\n+        forecast_points_per_period = 60 // self.forecast_resolution_minutes if self.forecast_resolution_minutes <= 60 else 1\r\n+        self._horizon_size = self.forecast_periods * forecast_points_per_period\r\n+\r\n+    def needs_resampling(self) -> bool:\r\n+        \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n+        return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n+\r\n+    def get_resampling_factor(self) -> float:\r\n+        \"\"\"Get the factor by which to resample the data.\"\"\"\r\n+        return self.forecast_resolution_minutes / self.input_resolution_minutes\r\n+\r\n+    def to_dict(self) -> Dict[str, Any]:\r\n+        \"\"\"Convert config to dictionary for serialization.\"\"\"\r\n+        return {\r\n+            'time_variable': self.time_variable,\r\n+            'target_variable': self.target_variable,\r\n+            'time_series_window_in_hours': self.time_series_window_in_hours,\r\n+            'forecasting_horizon_in_hours': self.forecasting_horizon_in_hours,\r\n+            'is_single_time_point_prediction': self.is_single_time_point_prediction,\r\n+            'include_time_information': self.include_time_information,\r\n+            'is_training_set': self.is_training_set,\r\n+            'labels_count': self.labels_count,\r\n+            'one_hot_time_variables': self.one_hot_time_variables,\r\n+            'normalize_data': self.normalize_data,\r\n+            'scaling_method': self.scaling_method,\r\n+            'time_resolution_minutes': self.time_resolution_minutes,\r\n+            'add_time_features': self.add_time_features,\r\n+            'add_holiday_features': self.add_holiday_features,\r\n+            'add_weather_features': self.add_weather_features\r\n+        }\r\n+\r\n+\r\n+class BaseDataset(ABC, Dataset):\r\n+    \"\"\"Base class for all datasets\"\"\"\r\n+\r\n+    def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n+        self._df = df\r\n+        self.config = config\r\n+        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n+        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n+        self.time_labels: Optional[np.ndarray] = None\r\n+        self.rows: Optional[torch.Tensor] = None\r\n+\r\n+    @abstractmethod\r\n+    def _prepare_time_series_data(self) -> None:\r\n+        \"\"\"Prepare time series data for model input\"\"\"\r\n+        pass\r\n+\r\n+    @abstractmethod\r\n+    def __len__(self) -> int:\r\n+        \"\"\"Return the number of items in the dataset\"\"\"\r\n+        pass\r\n+\r\n+    @abstractmethod\r\n+    def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n+        \"\"\"Get a data item by index\"\"\"\r\n+        pass\r\n+\r\n+    def get_number_of_input_features(self) -> int:\r\n+        \"\"\"Return number of input features\"\"\"\r\n+        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n+            return self.prepared_time_series_input.shape[1]\r\n+        return 0\r\n+\r\n+    def get_number_of_target_variables(self) -> int:\r\n+        \"\"\"Return number of target variables\"\"\"\r\n+        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n+            return self.prepared_time_series_target.shape[1]\r\n+        return 0\r\n+\r\n+    def _validate_data(self) -> None:\r\n+        \"\"\"Validate input data format and completeness.\"\"\"\r\n+        if self._df is None or self._df.empty:\r\n+            raise ValueError(\"Input DataFrame is empty or None\")\r\n+\r\n+        required_columns = [self.config.time_variable, self.config.target_variable]\r\n+        missing_columns = [col for col in required_columns if col not in self._df.columns]\r\n+        if missing_columns:\r\n+            raise ValueError(f\"Missing required columns: {missing_columns}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733133153753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,34 +7,37 @@\n import pandas as pd\r\n import numpy as np\r\n from sklearn.preprocessing import StandardScaler\r\n \r\n-from data_loading.types.interval_types import IntervalConfig\r\n+from data_loading.types.interval_types import IntervalConfig, TimeInterval\r\n \r\n @dataclass\r\n class DatasetConfig:\r\n     \"\"\"Configuration for dataset preparation.\"\"\"\r\n     # Required parameters\r\n     time_variable: str\r\n     target_variable: str\r\n     \r\n+    # Time resolution parameters\r\n     input_resolution_minutes: int   # Resolution of source data (e.g., 15 for 15-min data)\r\n     forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n-\r\n+    \r\n+    # Window and horizon configuration\r\n     lookback_periods: int      # How many periods to look back\r\n     forecast_periods: int      # How many periods to predict\r\n     \r\n+    # Feature and prediction configuration\r\n     is_single_time_point_prediction: bool\r\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n     one_hot_time_variables: bool\r\n-    \r\n+\r\n     # Data processing parameters with defaults\r\n     normalize_data: bool = False\r\n     scaling_method: str = \"standard\"\r\n     time_series_scaler: Any = None\r\n-    \r\n+\r\n     # Feature generation flags\r\n     add_time_features: bool = True\r\n     add_holiday_features: bool = False\r\n     add_weather_features: bool = False\r\n@@ -42,11 +45,21 @@\n     # Cache for computed values\r\n     _window_size: Optional[int] = field(init=False, default=None)\r\n     _horizon_size: Optional[int] = field(init=False, default=None)\r\n     _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n+    _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n+    _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n \r\n     def __post_init__(self):\r\n         \"\"\"Validate configuration and compute derived values.\"\"\"\r\n+        self._validate_resolutions()\r\n+        self._initialize_interval_config()\r\n+        self._initialize_scaler()\r\n+        self._compute_points_per_period()\r\n+        self._compute_window_sizes()\r\n+\r\n+    def _validate_resolutions(self) -> None:\r\n+        \"\"\"Validate input and forecast resolutions.\"\"\"\r\n         # Validate input resolution\r\n         if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n             raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n             \r\n@@ -60,22 +73,42 @@\n                 f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n                 f\"input resolution ({self.input_resolution_minutes} min)\"\r\n             )\r\n \r\n-        # Create interval configuration based on forecast resolution\r\n+    def _initialize_interval_config(self) -> None:\r\n+        \"\"\"Initialize the interval configuration.\"\"\"\r\n         self._interval_config = IntervalConfig(\r\n             interval_type=self._determine_interval_type(),\r\n             lookback_periods=self.lookback_periods,\r\n             forecast_periods=self.forecast_periods\r\n         )\r\n \r\n-        # Initialize scaler if needed\r\n+    def _initialize_scaler(self) -> None:\r\n+        \"\"\"Initialize the data scaler if needed.\"\"\"\r\n         if self.normalize_data and self.time_series_scaler is None:\r\n             self.time_series_scaler = StandardScaler() if self.scaling_method == \"standard\" else None\r\n \r\n-        # Compute window sizes considering both resolutions\r\n-        self._compute_window_sizes()\r\n+    def _compute_points_per_period(self) -> None:\r\n+        \"\"\"Compute points per period for both input and forecast resolutions.\"\"\"\r\n+        self._input_points_per_period = (\r\n+            60 // self.input_resolution_minutes \r\n+            if self.input_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n+        self._forecast_points_per_period = (\r\n+            60 // self.forecast_resolution_minutes \r\n+            if self.forecast_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n \r\n+    def _compute_window_sizes(self) -> None:\r\n+        \"\"\"Compute window sizes for input and forecast windows.\"\"\"\r\n+        if self._input_points_per_period is None or self._forecast_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+            \r\n+        self._window_size = self.lookback_periods * self._input_points_per_period\r\n+        self._horizon_size = self.forecast_periods * self._forecast_points_per_period\r\n+\r\n     def _determine_interval_type(self) -> TimeInterval:\r\n         \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n         resolution = self.forecast_resolution_minutes\r\n         if resolution <= 15:\r\n@@ -86,18 +119,36 @@\n             return TimeInterval.DAILY\r\n         else:\r\n             return TimeInterval.MONTHLY\r\n \r\n-    def _compute_window_sizes(self) -> None:\r\n-        \"\"\"Compute window sizes considering input and forecast resolutions.\"\"\"\r\n-        # Calculate input points based on input resolution\r\n-        input_points_per_period = 60 // self.input_resolution_minutes if self.input_resolution_minutes <= 60 else 1\r\n-        self._window_size = self.lookback_periods * input_points_per_period\r\n+    @property\r\n+    def window_size(self) -> int:\r\n+        \"\"\"Get window size in number of data points.\"\"\"\r\n+        if self._window_size is None:\r\n+            self._compute_window_sizes()\r\n+        return self._window_size\r\n \r\n-        # Calculate output points based on forecast resolution\r\n-        forecast_points_per_period = 60 // self.forecast_resolution_minutes if self.forecast_resolution_minutes <= 60 else 1\r\n-        self._horizon_size = self.forecast_periods * forecast_points_per_period\r\n+    @property\r\n+    def horizon_size(self) -> int:\r\n+        \"\"\"Get forecast horizon in number of data points.\"\"\"\r\n+        if self._horizon_size is None:\r\n+            self._compute_window_sizes()\r\n+        return self._horizon_size\r\n \r\n+    @property\r\n+    def input_points_per_period(self) -> int:\r\n+        \"\"\"Get number of input data points per period.\"\"\"\r\n+        if self._input_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        return self._input_points_per_period\r\n+\r\n+    @property\r\n+    def forecast_points_per_period(self) -> int:\r\n+        \"\"\"Get number of forecast points per period.\"\"\"\r\n+        if self._forecast_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        return self._forecast_points_per_period\r\n+\r\n     def needs_resampling(self) -> bool:\r\n         \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n         return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n \r\n@@ -109,179 +160,30 @@\n         \"\"\"Convert config to dictionary for serialization.\"\"\"\r\n         return {\r\n             'time_variable': self.time_variable,\r\n             'target_variable': self.target_variable,\r\n-            'time_series_window_in_hours': self.time_series_window_in_hours,\r\n-            'forecasting_horizon_in_hours': self.forecasting_horizon_in_hours,\r\n+            'input_resolution_minutes': self.input_resolution_minutes,\r\n+            'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n+            'lookback_periods': self.lookback_periods,\r\n+            'forecast_periods': self.forecast_periods,\r\n             'is_single_time_point_prediction': self.is_single_time_point_prediction,\r\n             'include_time_information': self.include_time_information,\r\n             'is_training_set': self.is_training_set,\r\n             'labels_count': self.labels_count,\r\n             'one_hot_time_variables': self.one_hot_time_variables,\r\n             'normalize_data': self.normalize_data,\r\n             'scaling_method': self.scaling_method,\r\n-            'time_resolution_minutes': self.time_resolution_minutes,\r\n             'add_time_features': self.add_time_features,\r\n             'add_holiday_features': self.add_holiday_features,\r\n             'add_weather_features': self.add_weather_features\r\n         }\r\n \r\n+    def get_interval_config(self) -> Optional[IntervalConfig]:\r\n+        \"\"\"Get the interval configuration.\"\"\"\r\n+        return self._interval_config\r\n \r\n-class BaseDataset(ABC, Dataset):\r\n-    \"\"\"Base class for all datasets\"\"\"\r\n \r\n-    def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n-        self._df = df\r\n-        self.config = config\r\n-        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n-        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n-        self.time_labels: Optional[np.ndarray] = None\r\n-        self.rows: Optional[torch.Tensor] = None\r\n \r\n-    @abstractmethod\r\n-    def _prepare_time_series_data(self) -> None:\r\n-        \"\"\"Prepare time series data for model input\"\"\"\r\n-        pass\r\n-\r\n-    @abstractmethod\r\n-    def __len__(self) -> int:\r\n-        \"\"\"Return the number of items in the dataset\"\"\"\r\n-        pass\r\n-\r\n-    @abstractmethod\r\n-    def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n-        \"\"\"Get a data item by index\"\"\"\r\n-        pass\r\n-\r\n-    def get_number_of_input_features(self) -> int:\r\n-        \"\"\"Return number of input features\"\"\"\r\n-        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n-            return self.prepared_time_series_input.shape[1]\r\n-        return 0\r\n-\r\n-    def get_number_of_target_variables(self) -> int:\r\n-        \"\"\"Return number of target variables\"\"\"\r\n-        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n-            return self.prepared_time_series_target.shape[1]\r\n-        return 0\r\n-\r\n-    def _validate_data(self) -> None:\r\n-        \"\"\"Validate input data format and completeness.\"\"\"\r\n-        if self._df is None or self._df.empty:\r\n-            raise ValueError(\"Input DataFrame is empty or None\")\r\n-\r\n-        required_columns = [self.config.time_variable, self.config.target_variable]\r\n-        missing_columns = [col for col in required_columns if col not in self._df.columns]\r\n-        if missing_columns:\r\n-            raise ValueError(f\"Missing required columns: {missing_columns}\")\n-# path: data_loading/base/base_dataset.py\r\n-from abc import ABC, abstractmethod\r\n-from dataclasses import dataclass, field\r\n-from typing import Tuple, Any, Optional, Dict\r\n-import torch\r\n-from torch.utils.data import Dataset\r\n-import pandas as pd\r\n-import numpy as np\r\n-from sklearn.preprocessing import StandardScaler\r\n-\r\n-from data_loading.types.interval_types import IntervalConfig\r\n-\r\n-@dataclass\r\n-class DatasetConfig:\r\n-    \"\"\"Configuration for dataset preparation.\"\"\"\r\n-    # Required parameters\r\n-    time_variable: str\r\n-    target_variable: str\r\n-    \r\n-    input_resolution_minutes: int   # Resolution of source data (e.g., 15 for 15-min data)\r\n-    forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n-\r\n-    lookback_periods: int      # How many periods to look back\r\n-    forecast_periods: int      # How many periods to predict\r\n-    \r\n-    is_single_time_point_prediction: bool\r\n-    include_time_information: bool\r\n-    is_training_set: bool\r\n-    labels_count: int\r\n-    one_hot_time_variables: bool\r\n-    \r\n-    # Data processing parameters with defaults\r\n-    normalize_data: bool = False\r\n-    scaling_method: str = \"standard\"\r\n-    time_series_scaler: Any = None\r\n-    \r\n-    # Feature generation flags\r\n-    add_time_features: bool = True\r\n-    add_holiday_features: bool = False\r\n-    add_weather_features: bool = False\r\n-\r\n-    # Cache for computed values\r\n-    _window_size: Optional[int] = field(init=False, default=None)\r\n-    _horizon_size: Optional[int] = field(init=False, default=None)\r\n-    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n-\r\n-    def __post_init__(self):\r\n-        \"\"\"Validate configuration and compute derived values.\"\"\"\r\n-        # Validate input resolution\r\n-        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n-            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n-            \r\n-        # Validate forecast resolution\r\n-        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n-            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n-            \r\n-        # Validate that forecast resolution is not finer than input resolution\r\n-        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n-            raise ValueError(\r\n-                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n-                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n-            )\r\n-\r\n-        # Create interval configuration based on forecast resolution\r\n-        self._interval_config = IntervalConfig(\r\n-            interval_type=self._determine_interval_type(),\r\n-            lookback_periods=self.lookback_periods,\r\n-            forecast_periods=self.forecast_periods\r\n-        )\r\n-\r\n-        # Initialize scaler if needed\r\n-        if self.normalize_data and self.time_series_scaler is None:\r\n-            self.time_series_scaler = StandardScaler() if self.scaling_method == \"standard\" else None\r\n-\r\n-        # Compute window sizes considering both resolutions\r\n-        self._compute_window_sizes()\r\n-\r\n-    @property\r\n-    def window_size(self) -> int:\r\n-        \"\"\"Get window size in number of data points.\"\"\"\r\n-        return self._window_size if self._window_size is not None else self.time_series_window_in_hours * self.points_per_hour\r\n-\r\n-    @property\r\n-    def horizon_size(self) -> int:\r\n-        \"\"\"Get forecast horizon in number of data points.\"\"\"\r\n-        return self._horizon_size if self._horizon_size is not None else self.forecasting_horizon_in_hours * self.points_per_hour\r\n-\r\n-    def to_dict(self) -> Dict[str, Any]:\r\n-        \"\"\"Convert config to dictionary for serialization.\"\"\"\r\n-        return {\r\n-            'time_variable': self.time_variable,\r\n-            'target_variable': self.target_variable,\r\n-            'time_series_window_in_hours': self.time_series_window_in_hours,\r\n-            'forecasting_horizon_in_hours': self.forecasting_horizon_in_hours,\r\n-            'is_single_time_point_prediction': self.is_single_time_point_prediction,\r\n-            'include_time_information': self.include_time_information,\r\n-            'is_training_set': self.is_training_set,\r\n-            'labels_count': self.labels_count,\r\n-            'one_hot_time_variables': self.one_hot_time_variables,\r\n-            'normalize_data': self.normalize_data,\r\n-            'scaling_method': self.scaling_method,\r\n-            'time_resolution_minutes': self.time_resolution_minutes,\r\n-            'add_time_features': self.add_time_features,\r\n-            'add_holiday_features': self.add_holiday_features,\r\n-            'add_weather_features': self.add_weather_features\r\n-        }\r\n-\r\n-\r\n class BaseDataset(ABC, Dataset):\r\n     \"\"\"Base class for all datasets\"\"\"\r\n \r\n     def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n"
                },
                {
                    "date": 1733134514706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,11 +103,14 @@\n     def _compute_window_sizes(self) -> None:\r\n         \"\"\"Compute window sizes for input and forecast windows.\"\"\"\r\n         if self._input_points_per_period is None or self._forecast_points_per_period is None:\r\n             self._compute_points_per_period()\r\n+        \r\n+        input_points = self._input_points_per_period or 0  # Default to 0 if None\r\n+        forecast_points = self._forecast_points_per_period or 0  # Default to 0 if None\r\n             \r\n-        self._window_size = self.lookback_periods * self._input_points_per_period\r\n-        self._horizon_size = self.forecast_periods * self._forecast_points_per_period\r\n+        self._window_size = self.lookback_periods * input_points\r\n+        self._horizon_size = self.forecast_periods * forecast_points\r\n \r\n     def _determine_interval_type(self) -> TimeInterval:\r\n         \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n         resolution = self.forecast_resolution_minutes\r\n@@ -124,29 +127,33 @@\n     def window_size(self) -> int:\r\n         \"\"\"Get window size in number of data points.\"\"\"\r\n         if self._window_size is None:\r\n             self._compute_window_sizes()\r\n+        assert self._window_size is not None\r\n         return self._window_size\r\n \r\n     @property\r\n     def horizon_size(self) -> int:\r\n         \"\"\"Get forecast horizon in number of data points.\"\"\"\r\n         if self._horizon_size is None:\r\n             self._compute_window_sizes()\r\n+        assert self._horizon_size is not None\r\n         return self._horizon_size\r\n \r\n     @property\r\n     def input_points_per_period(self) -> int:\r\n         \"\"\"Get number of input data points per period.\"\"\"\r\n         if self._input_points_per_period is None:\r\n             self._compute_points_per_period()\r\n+        assert self._input_points_per_period is not None\r\n         return self._input_points_per_period\r\n \r\n     @property\r\n     def forecast_points_per_period(self) -> int:\r\n         \"\"\"Get number of forecast points per period.\"\"\"\r\n         if self._forecast_points_per_period is None:\r\n             self._compute_points_per_period()\r\n+        assert self._forecast_points_per_period is not None\r\n         return self._forecast_points_per_period\r\n \r\n     def needs_resampling(self) -> bool:\r\n         \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n"
                },
                {
                    "date": 1733178396158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,7 +233,8 @@\n         if self._df is None or self._df.empty:\r\n             raise ValueError(\"Input DataFrame is empty or None\")\r\n \r\n         required_columns = [self.config.time_variable, self.config.target_variable]\r\n-        missing_columns = [col for col in required_columns if col not in self._df.columns]\r\n-        if missing_columns:\r\n+        if missing_columns := [\r\n+            col for col in required_columns if col not in self._df.columns\r\n+        ]:\r\n             raise ValueError(f\"Missing required columns: {missing_columns}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733180683909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,8 +154,27 @@\n             self._compute_points_per_period()\r\n         assert self._forecast_points_per_period is not None\r\n         return self._forecast_points_per_period\r\n \r\n+    @property\r\n+    def time_series_window_in_hours(self) -> int:\r\n+        \"\"\"Get lookback window size in hours.\"\"\"\r\n+        return self.lookback_periods * (self.input_resolution_minutes // 60) \\\r\n+            if self.input_resolution_minutes >= 60 \\\r\n+            else self.lookback_periods // (60 // self.input_resolution_minutes)\r\n+\r\n+    @property\r\n+    def forecasting_horizon_in_hours(self) -> int:\r\n+        \"\"\"Get forecast horizon in hours.\"\"\"\r\n+        return self.forecast_periods * (self.forecast_resolution_minutes // 60) \\\r\n+            if self.forecast_resolution_minutes >= 60 \\\r\n+            else self.forecast_periods // (60 // self.forecast_resolution_minutes)\r\n+\r\n+    @property\r\n+    def points_per_hour(self) -> int:\r\n+        \"\"\"Get number of data points per hour.\"\"\"\r\n+        return 60 // self.input_resolution_minutes if self.input_resolution_minutes <= 60 else 1\r\n+\r\n     def needs_resampling(self) -> bool:\r\n         \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n         return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n \r\n"
                },
                {
                    "date": 1733183676080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n # path: data_loading/base/base_dataset.py\r\n from abc import ABC, abstractmethod\r\n from dataclasses import dataclass, field\r\n-from typing import Tuple, Any, Optional, Dict\r\n+from typing import List, Tuple, Any, Optional, Dict\r\n import torch\r\n from torch.utils.data import Dataset\r\n import pandas as pd\r\n import numpy as np\r\n@@ -11,22 +11,22 @@\n from data_loading.types.interval_types import IntervalConfig, TimeInterval\r\n \r\n @dataclass\r\n class DatasetConfig:\r\n-    \"\"\"Configuration for dataset preparation.\"\"\"\r\n-    # Required parameters\r\n+    \"\"\"Configuration for dataset preparation with enhanced feature control.\"\"\"\r\n+    # Required core parameters\r\n     time_variable: str\r\n     target_variable: str\r\n     \r\n     # Time resolution parameters\r\n-    input_resolution_minutes: int   # Resolution of source data (e.g., 15 for 15-min data)\r\n-    forecast_resolution_minutes: int # Resolution of predictions (e.g., 60 for hourly predictions)\r\n+    input_resolution_minutes: int\r\n+    forecast_resolution_minutes: int\r\n     \r\n     # Window and horizon configuration\r\n-    lookback_periods: int      # How many periods to look back\r\n-    forecast_periods: int      # How many periods to predict\r\n+    lookback_periods: int\r\n+    forecast_periods: int\r\n     \r\n-    # Feature and prediction configuration\r\n+    # Core feature and prediction configuration\r\n     is_single_time_point_prediction: bool\r\n     include_time_information: bool\r\n     is_training_set: bool\r\n     labels_count: int\r\n@@ -35,14 +35,34 @@\n     # Data processing parameters with defaults\r\n     normalize_data: bool = False\r\n     scaling_method: str = \"standard\"\r\n     time_series_scaler: Any = None\r\n+    handle_missing_values: str = \"interpolate\"\r\n+    remove_outliers: bool = False\r\n+    outlier_std_threshold: float = 3.0\r\n \r\n-    # Feature generation flags\r\n+    # Basic feature generation flags\r\n     add_time_features: bool = True\r\n     add_holiday_features: bool = False\r\n     add_weather_features: bool = False\r\n \r\n+    # Detailed time feature controls\r\n+    add_hour_feature: bool = True\r\n+    add_weekday_feature: bool = True\r\n+    add_month_feature: bool = True\r\n+    add_season_feature: bool = False\r\n+    add_year_feature: bool = False\r\n+    \r\n+    # Data augmentation settings\r\n+    use_data_augmentation: bool = False\r\n+    augmentation_methods: List[str] = field(default_factory=lambda: [\"jitter\", \"scaling\"])\r\n+    augmentation_probability: float = 0.3\r\n+\r\n+    # Sequence handling\r\n+    padding_value: float = 0.0\r\n+    mask_padding: bool = True\r\n+    max_sequence_gaps: int = 3\r\n+\r\n     # Cache for computed values\r\n     _window_size: Optional[int] = field(init=False, default=None)\r\n     _horizon_size: Optional[int] = field(init=False, default=None)\r\n     _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n@@ -56,8 +76,9 @@\n         self._initialize_scaler()\r\n         self._compute_points_per_period()\r\n         self._compute_window_sizes()\r\n \r\n+\r\n     def _validate_resolutions(self) -> None:\r\n         \"\"\"Validate input and forecast resolutions.\"\"\"\r\n         # Validate input resolution\r\n         if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n"
                }
            ],
            "date": 1733003949084,
            "name": "Commit-0",
            "content": "# data_loading/base/base_dataset.py\r\nfrom abc import ABC, abstractmethod\r\nfrom dataclasses import dataclass\r\nfrom typing import Tuple, Any, Optional\r\nimport torch\r\nfrom torch.utils.data import Dataset\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom sklearn.preprocessing import StandardScaler\r\n\r\n@dataclass\r\nclass DatasetConfig:\r\n    \"\"\"Configuration for dataset preparation.\"\"\"\r\n    time_variable: str\r\n    target_variable: str\r\n    time_series_window_in_hours: int\r\n    forecasting_horizon_in_hours: int\r\n    is_single_time_point_prediction: bool\r\n    include_time_information: bool\r\n    is_training_set: bool\r\n    labels_count: int\r\n    one_hot_time_variables: bool\r\n    normalize_data: bool = False  # Add with default False\r\n    scaling_method: str = \"standard\"  # Add with default \"standard\"\r\n    time_series_scaler: Any = None  # Add to store scaler instance\r\n\r\nclass BaseDataset(ABC, Dataset):\r\n    \"\"\"Base class for all datasets\"\"\"\r\n\r\n    def __init__(self, df: pd.DataFrame, config: DatasetConfig):\r\n        self._df = df\r\n        self.config = config\r\n        self.prepared_time_series_input: Optional[torch.Tensor] = None\r\n        self.prepared_time_series_target: Optional[torch.Tensor] = None\r\n        self.time_labels: Optional[np.ndarray] = None\r\n        self.rows: Optional[torch.Tensor] = None\r\n\r\n    @abstractmethod\r\n    def _prepare_time_series_data(self) -> None:\r\n        \"\"\"Prepare time series data for model input\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def __len__(self) -> int:\r\n        \"\"\"Return the number of items in the dataset\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def __getitem__(self, index: int) -> Tuple[Any, Any]:\r\n        \"\"\"Get a data item by index\"\"\"\r\n        pass\r\n\r\n    def get_number_of_input_features(self) -> int:\r\n        \"\"\"Return number of input features\"\"\"\r\n        if hasattr(self, 'prepared_time_series_input') and self.prepared_time_series_input is not None:\r\n            return self.prepared_time_series_input.shape[1]\r\n        return 0\r\n\r\n    def get_number_of_target_variables(self) -> int:\r\n        \"\"\"Return number of target variables\"\"\"\r\n        if hasattr(self, 'prepared_time_series_target') and self.prepared_time_series_target is not None:\r\n            return self.prepared_time_series_target.shape[1]\r\n        return 0"
        }
    ]
}