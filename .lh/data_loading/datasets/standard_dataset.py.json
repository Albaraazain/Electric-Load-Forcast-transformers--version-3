{
    "sourceFile": "data_loading/datasets/standard_dataset.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733061971729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733061971729,
            "name": "Commit-0",
            "content": "# data_loading/datasets/standard_dataset.py\r\nimport numpy as np\r\nimport pandas as pd\r\nimport torch\r\nfrom typing import Tuple\r\n\r\nfrom data_loading.base.base_dataset import BaseDataset, DatasetConfig\r\nfrom data_loading.features.time_features import CyclicalTimeFeature, OneHotTimeFeature, WorkdayFeature\r\nfrom data_loading.preprocessing.data_scaler import DataScaler\r\nfrom data_loading.preprocessing.data_transformer import DataTransformer\r\n\r\n\r\nclass StandardDataset(BaseDataset):\r\n    \"\"\"Dataset implementation for standard ML models (linear regression, neural nets)\"\"\"\r\n\r\n    def __init__(self, df, config: DatasetConfig):\r\n        super().__init__(df, config)\r\n        self.prepared_time_series_input: torch.Tensor = torch.zeros((0,))\r\n        self.prepared_time_series_target: torch.Tensor = torch.zeros((0,))\r\n        self._prepare_time_series_data()\r\n\r\n    def __len__(self) -> int:\r\n        return len(self.prepared_time_series_input)\r\n\r\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor]:\r\n        if self.prepared_time_series_input is None or self.prepared_time_series_target is None:\r\n            raise ValueError(\"Dataset not properly initialized\")\r\n        \r\n        if index >= len(self.prepared_time_series_input):\r\n            raise IndexError(f\"Index {index} out of bounds for dataset of size {len(self.prepared_time_series_input)}\")\r\n            \r\n        return (\r\n            self.prepared_time_series_input[index],\r\n            self.prepared_time_series_target[index]\r\n        )\r\n\r\n    def _prepare_time_series_data(self) -> None:\r\n        # Initialize data processor\r\n        scaler = DataScaler(self.config.time_series_scaler)\r\n\r\n        # Extract raw data (already in 15-min intervals)\r\n        load_data = np.array(self._df[self.config.target_variable])\r\n        time_stamps = np.array(self._df[self.config.time_variable])\r\n\r\n        # Scale data\r\n        scaled_load_data = (\r\n            scaler.fit_transform(load_data)\r\n            if self.config.is_training_set\r\n            else scaler.transform(load_data)\r\n        ) if self.config.time_series_scaler else load_data\r\n\r\n        target_rows = []\r\n        input_rows = []\r\n\r\n        # Initialize feature generators\r\n        hour_feature = (\r\n            OneHotTimeFeature(24) if self.config.one_hot_time_variables\r\n            else CyclicalTimeFeature(24)\r\n        )\r\n        month_feature = (\r\n            OneHotTimeFeature(12) if self.config.one_hot_time_variables\r\n            else CyclicalTimeFeature(53)\r\n        )\r\n        workday_feature = WorkdayFeature()\r\n\r\n        # Generate input/target pairs\r\n        for idx in range(\r\n                self.config.time_series_window_in_hours,\r\n                len(scaled_load_data) - self.config.forecasting_horizon_in_hours\r\n        ):\r\n            # Prepare target\r\n            if self.config.is_single_time_point_prediction:\r\n                target = [scaled_load_data[idx + self.config.forecasting_horizon_in_hours]]\r\n            else:\r\n                target = scaled_load_data[idx:idx + self.config.forecasting_horizon_in_hours]\r\n            target_rows.append(target)\r\n\r\n            # Prepare input features\r\n            features = []\r\n\r\n            # Add time series values\r\n            features.extend(\r\n                scaled_load_data[idx - self.config.time_series_window_in_hours:idx]\r\n            )\r\n\r\n            if self.config.include_time_information:\r\n                prediction_datetime = pd.to_datetime(time_stamps[idx])\r\n\r\n                # Add time features\r\n                features.extend(hour_feature.generate(prediction_datetime.hour))\r\n                features.extend(month_feature.generate(prediction_datetime.month - 1))\r\n\r\n                # Add workday features\r\n                if self.config.is_single_time_point_prediction:\r\n                    features.extend(workday_feature.generate(prediction_datetime))\r\n                else:\r\n                    for t in time_stamps[idx:idx + self.config.forecasting_horizon_in_hours]:\r\n                        features.extend(workday_feature.generate(t))\r\n\r\n            input_rows.append(features)\r\n\r\n        # Convert to tensors\r\n        self.prepared_time_series_input = torch.tensor(\r\n            np.array(input_rows),\r\n            dtype=torch.float32\r\n        )\r\n        self.prepared_time_series_target = torch.tensor(\r\n            np.array(target_rows),\r\n            dtype=torch.float32\r\n        )\r\n        self.time_labels = time_stamps[\r\n                        self.config.time_series_window_in_hours:\r\n                        len(scaled_load_data) - self.config.forecasting_horizon_in_hours\r\n                        ]"
        }
    ]
}