{
    "sourceFile": "data_loading/loaders/time_series_loader.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733177367424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733177367424,
            "name": "Commit-0",
            "content": "# data_loading/loaders/time_series_loader.py\r\nfrom dataclasses import dataclass\r\nfrom datetime import date\r\nfrom pathlib import Path\r\nfrom typing import List, Tuple, Union, cast\r\nimport pandas as pd\r\nfrom pandas import DataFrame\r\n\r\nfrom data_loading.base.base_loader import BaseLoader\r\n\r\n\r\n@dataclass\r\nclass TimeInterval:\r\n    \"\"\"Represents a time interval with inclusive bounds\"\"\"\r\n    min_date: date\r\n    max_date: date  # Fixed: Added type annotation\r\n\r\n    def is_interval_overlapping(self, other: 'TimeInterval') -> bool:\r\n        \"\"\"Check if this interval overlaps with another interval\"\"\"\r\n        return not (\r\n            self.min_date > other.max_date or\r\n            self.max_date < other.min_date\r\n        )\r\n\r\nclass TimeSeriesLoader(BaseLoader):\r\n    \"\"\"Loads and splits time series data from CSV files\"\"\"\r\n\r\n    def __init__(self, time_variable: str, target_variable: str):\r\n        self.time_variable = time_variable\r\n        self.target_variable = target_variable\r\n        self.csv_dataframe = None\r\n\r\n    def _load_dataframe_from_csv(self, path: Union[str, Path], columns_to_parse_as_dates: List[str], columns_to_include: List[str]) -> pd.DataFrame:\r\n        \"\"\"Load CSV file into DataFrame with specific parsing requirements\"\"\"\r\n        try:\r\n            df = pd.read_csv(\r\n                path,\r\n                usecols=columns_to_include,\r\n                parse_dates=columns_to_parse_as_dates\r\n            )\r\n            \r\n            if missing_cols := set(columns_to_include) - set(df.columns):  # Using walrus operator\r\n                raise ValueError(f\"Missing required columns: {missing_cols}\")\r\n                \r\n            return df\r\n            \r\n        except Exception as e:\r\n            raise IOError(f\"Error loading CSV file: {str(e)}\") from e\r\n\r\n    def load(self, path: Union[str, Path]) -> pd.DataFrame:\r\n        \"\"\"Load data from CSV file\"\"\"\r\n        self.csv_dataframe = self._load_dataframe_from_csv(\r\n            path=path,\r\n            columns_to_parse_as_dates=[self.time_variable],\r\n            columns_to_include=[self.time_variable, self.target_variable]\r\n        )\r\n        print(\"Debug: Loaded DataFrame time column type:\", self.csv_dataframe[self.time_variable].dtype)\r\n        sample_time = pd.Timestamp(cast(pd.Timestamp, self.csv_dataframe[self.time_variable].iloc[0])) # type: ignore\r\n        print(\"Debug: Sample time value:\", sample_time)\r\n        return self.csv_dataframe\r\n\r\n    def split(\r\n            self,\r\n            df: pd.DataFrame,\r\n            train_interval: TimeInterval,\r\n            validation_interval: TimeInterval,\r\n            test_interval: TimeInterval\r\n    ) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\r\n        \"\"\"Split data into train, validation and test sets\"\"\"\r\n        print(\"Debug: Splitting data...\")\r\n\r\n        # Debug: Log intervals\r\n        print(\"Debug: Train Interval:\", train_interval)\r\n        print(\"Debug: Validation Interval:\", validation_interval)\r\n        print(\"Debug: Test Interval:\", test_interval)\r\n\r\n        if df is None or df.empty:\r\n            raise ValueError(\"Input DataFrame must not be None or empty\")\r\n\r\n        if (train_interval.is_interval_overlapping(validation_interval) or\r\n                validation_interval.is_interval_overlapping(test_interval)):\r\n            raise ValueError(\"Train, validation and test intervals must not overlap\")\r\n\r\n        train_data = self._extract_by_interval(df, train_interval)\r\n        val_data = self._extract_by_interval(df, validation_interval)\r\n        test_data = self._extract_by_interval(df, test_interval)\r\n\r\n        # Debug: Log split results\r\n        print(\"Debug: Train data shape:\", train_data.shape)\r\n        print(\"Debug: Validation data shape:\", val_data.shape)\r\n        print(\"Debug: Test data shape:\", test_data.shape)\r\n\r\n        return train_data, val_data, test_data\r\n\r\n    def _extract_by_interval(self, df: pd.DataFrame, interval: TimeInterval) -> pd.DataFrame:\r\n        \"\"\"Extract subset of data within given time interval\"\"\"\r\n        filtered_df = df[\r\n            (df[self.time_variable].dt.date >= interval.min_date) &\r\n            (df[self.time_variable].dt.date <= interval.max_date)\r\n        ]\r\n        \r\n        if filtered_df.empty:\r\n            print(f\"Warning: No data found for interval {interval.min_date} to {interval.max_date}\")\r\n            # Create a minimal dataframe with the same columns but a single row of default values\r\n            default_row = pd.DataFrame({\r\n                self.time_variable: [pd.Timestamp(interval.min_date)],\r\n                self.target_variable: [0.0]\r\n            })\r\n            return default_row\r\n        \r\n        return filtered_df\r\n\r\n    def resample_data(self, df: pd.DataFrame, target_resolution_minutes: int) -> pd.DataFrame:\r\n        \"\"\"Resample data to match the target resolution.\"\"\"\r\n        # Implementation for resampling data\r\n        return df  # Ensure it returns a DataFrame"
        }
    ]
}