{
    "sourceFile": "evaluation/metrics.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733177653830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733177653830,
            "name": "Commit-0",
            "content": "# evaluation/metrics.py\r\nfrom typing import Dict, Optional\r\n\r\nimport torch\r\nimport numpy as np\r\nfrom dataclasses import dataclass\r\n\r\nfrom torch import Tensor\r\n\r\n\r\n@dataclass\r\nclass MetricConfig:\r\n    \"\"\"Configuration for metric calculations.\"\"\"\r\n    resolution_minutes: Optional[int] = None\r\n    rmse_threshold: float = 0.05\r\n    mae_threshold: float = 0.05\r\n    mape_threshold: float = 0.05\r\n    r2_threshold: float = 0.95\r\n    seasonal_period: int = 168  # Default weekly seasonality\r\n    epsilon: float = 1e-8  # Small value for numerical stability\r\n\r\nclass Metrics:\r\n    \"\"\"Collection of evaluation metrics.\"\"\"\r\n\r\n    @staticmethod\r\n    def mape(predicted: Tensor, expected: Tensor, epsilon: float = 1e-8) -> float:\r\n        \"\"\"Mean Absolute Percentage Error.\"\"\"\r\n        # Ensure tensors are properly aligned\r\n        error = torch.abs((expected - predicted) / (torch.abs(expected) + epsilon))\r\n        return torch.mean(error).item() * 100\r\n\r\n    @staticmethod\r\n    def mase(predicted: Tensor, expected: Tensor, seasonal_period: int) -> float:\r\n        \"\"\"Mean Absolute Scaled Error.\"\"\"\r\n        # Ensure inputs are 2D: [time, features]\r\n        if predicted.dim() > 2:\r\n            predicted = predicted.reshape(-1, predicted.size(-1))\r\n            expected = expected.reshape(-1, expected.size(-1))\r\n\r\n        # Calculate MAE\r\n        mae = torch.mean(torch.abs(expected - predicted))\r\n\r\n        # Calculate denominator (mean absolute error of naive seasonal forecast)\r\n        naive_errors = []\r\n        for i in range(seasonal_period, len(expected)):\r\n            error = torch.abs(expected[i] - expected[i - seasonal_period])\r\n            naive_errors.append(error)\r\n        \r\n        if not naive_errors:\r\n            return float('nan')\r\n            \r\n        naive_errors_tensor = torch.stack(naive_errors)\r\n        naive_mae = torch.mean(naive_errors_tensor)\r\n        \r\n        if naive_mae == 0:\r\n            return float('inf')\r\n            \r\n        return (mae / naive_mae).item()\r\n\r\n    @staticmethod\r\n    def rmse(predicted: Tensor, expected: Tensor) -> float:\r\n        \"\"\"Root Mean Square Error.\"\"\"\r\n        # Ensure tensors are properly aligned\r\n        return torch.sqrt(torch.mean((predicted - expected) ** 2)).item()\r\n\r\n    @staticmethod\r\n    def mae(predicted: Tensor, expected: Tensor) -> float:\r\n        \"\"\"Mean Absolute Error.\"\"\"\r\n        # Ensure tensors are properly aligned\r\n        return torch.mean(torch.abs(expected - predicted)).item()\r\n\r\n    @staticmethod\r\n    def calculate_all_metrics(predicted: Tensor, expected: Tensor, config: MetricConfig) -> Dict[str, float]:\r\n        \"\"\"Calculate all available metrics.\"\"\"\r\n        try:\r\n            mase_value = Metrics.mase(predicted, expected, config.seasonal_period)\r\n        except:\r\n            mase_value = float('nan')\r\n\r\n        return {\r\n            'mape': Metrics.mape(predicted, expected, config.epsilon),\r\n            'mase': mase_value,\r\n            'rmse': Metrics.rmse(predicted, expected),\r\n            'mae': Metrics.mae(predicted, expected)\r\n        }"
        }
    ]
}