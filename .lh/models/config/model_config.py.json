{
    "sourceFile": "models/config/model_config.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 18,
            "patches": [
                {
                    "date": 1733061971711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733091459162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-# models/config/model_config.py\r\n from dataclasses import dataclass, field\r\n from typing import Dict, Any, Optional, List\r\n \r\n from ..registry.model_types import ModelType\r\n@@ -15,12 +14,18 @@\n     n_encoder_layers: int = 6\r\n     n_decoder_layers: int = 6\r\n     d_ff: int = 2048\r\n     dropout: float = 0.1\r\n-    max_seq_length: int = 672  # Updated: 28 days * 24 hours * 4 intervals\r\n-    transformer_labels_count: int = 48  # Updated: 12 hours * 4 intervals\r\n-    points_per_interval: int = 4  # New field for 15-min intervals\r\n+    max_seq_length: int = 672  # 28 days * 24 hours * 4 intervals\r\n+    transformer_labels_count: int = 48  # 12 hours * 4 intervals\r\n+    points_per_interval: int = 4  # 15-min intervals\r\n     \r\n+    # Time series specific parameters\r\n+    value_features: int = 1  # Main time series value\r\n+    time_features: Optional[int] = None  # Additional time-based features\r\n+    kernel_size: int = 3  # For convolutional attention\r\n+    batch_first: bool = True  # Handle batch dimension first\r\n+    \r\n     # Neural network specific\r\n     hidden_dims: List[int] = field(default_factory=lambda: [64, 32])\r\n     activation: str = 'relu'\r\n \r\n@@ -37,8 +42,14 @@\n \r\n     # Device\r\n     device: str = 'cuda'\r\n \r\n+    def __post_init__(self):\r\n+        \"\"\"Post-initialization processing.\"\"\"\r\n+        # If time_features not specified, calculate from input features\r\n+        if self.time_features is None:\r\n+            self.time_features = max(0, self.input_features - self.value_features)\r\n+\r\n     def to_dict(self) -> Dict[str, Any]:\r\n         \"\"\"Convert config to dictionary.\"\"\"\r\n         return {k: v for k, v in self.__dict__.items() if v is not None}\r\n \r\n@@ -46,18 +57,22 @@\n     \"\"\"Get default configuration for specified model type.\"\"\"\r\n     base_config = {\r\n         'model_type': model_type,\r\n         'input_features': 1,\r\n-        'output_dim': 1\r\n+        'output_features': 1\r\n     }\r\n \r\n-    if model_type in {'vanilla_transformer', 'conv_transformer', 'informer'}:\r\n+    if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n         base_config.update({\r\n-            'd_model': 512,\r\n+            'd_model': 256,\r\n             'n_heads': 8,\r\n-            'n_encoder_layers': 3,\r\n-            'n_decoder_layers': 3,\r\n-            'd_ff': 2048,\r\n-            'dropout': 0.1,\r\n+            'n_encoder_layers': 4,\r\n+            'n_decoder_layers': 4,\r\n+            'd_ff': 1024,\r\n+            'dropout': 0.2,\r\n+            'kernel_size': 3,\r\n+            'max_seq_length': 96,  # 24 hours * 4 intervals\r\n+            'transformer_labels_count': 48,  # 12 hours ahead\r\n+            'batch_first': True\r\n         })\r\n \r\n     return ModelConfig(**base_config)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733134528148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,24 +1,30 @@\n from dataclasses import dataclass, field\r\n from typing import Dict, Any, Optional, List\r\n-\r\n from ..registry.model_types import ModelType\r\n+from ...data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n \r\n @dataclass\r\n class ModelConfig:\r\n     \"\"\"Configuration for model architecture.\"\"\"\r\n+    # Core model identification\r\n     model_type: ModelType\r\n+    \r\n+    # Time resolution and sequence configuration\r\n+    input_resolution_minutes: int\r\n+    forecast_resolution_minutes: int\r\n+    lookback_periods: int\r\n+    forecast_periods: int\r\n+    \r\n+    # Model architecture parameters\r\n     input_features: int\r\n     output_features: int = 1\r\n     d_model: int = 512\r\n     n_heads: int = 8\r\n     n_encoder_layers: int = 6\r\n     n_decoder_layers: int = 6\r\n     d_ff: int = 2048\r\n     dropout: float = 0.1\r\n-    max_seq_length: int = 672  # 28 days * 24 hours * 4 intervals\r\n-    transformer_labels_count: int = 48  # 12 hours * 4 intervals\r\n-    points_per_interval: int = 4  # 15-min intervals\r\n     \r\n     # Time series specific parameters\r\n     value_features: int = 1  # Main time series value\r\n     time_features: Optional[int] = None  # Additional time-based features\r\n@@ -42,37 +48,134 @@\n \r\n     # Device\r\n     device: str = 'cuda'\r\n \r\n+    # Cache for computed values\r\n+    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n+    _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n+    _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n+\r\n     def __post_init__(self):\r\n         \"\"\"Post-initialization processing.\"\"\"\r\n+        self._validate_resolutions()\r\n+        self._initialize_interval_config()\r\n+        self._compute_points_per_period()\r\n+        \r\n         # If time_features not specified, calculate from input features\r\n         if self.time_features is None:\r\n             self.time_features = max(0, self.input_features - self.value_features)\r\n \r\n-    def to_dict(self) -> Dict[str, Any]:\r\n-        \"\"\"Convert config to dictionary.\"\"\"\r\n-        return {k: v for k, v in self.__dict__.items() if v is not None}\r\n+    def _validate_resolutions(self) -> None:\r\n+        \"\"\"Validate input and forecast resolutions.\"\"\"\r\n+        # Validate input resolution\r\n+        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate forecast resolution\r\n+        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate that forecast resolution is not finer than input resolution\r\n+        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n+            raise ValueError(\r\n+                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n+                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n\\ No newline at end of file\n+            )\r\n \r\n-def get_default_config(model_type: str) -> ModelConfig:\r\n-    \"\"\"Get default configuration for specified model type.\"\"\"\r\n-    base_config = {\r\n-        'model_type': model_type,\r\n-        'input_features': 1,\r\n-        'output_features': 1\r\n-    }\r\n+    def _initialize_interval_config(self) -> None:\r\n+        \"\"\"Initialize the interval configuration.\"\"\"\r\n+        self._interval_config = IntervalConfig(\r\n+            interval_type=self._determine_interval_type(),\r\n+            lookback_periods=self.lookback_periods,\r\n+            forecast_periods=self.forecast_periods\r\n+        )\r\n \r\n-    if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n-        base_config.update({\r\n-            'd_model': 256,\r\n-            'n_heads': 8,\r\n-            'n_encoder_layers': 4,\r\n-            'n_decoder_layers': 4,\r\n-            'd_ff': 1024,\r\n-            'dropout': 0.2,\r\n-            'kernel_size': 3,\r\n-            'max_seq_length': 96,  # 24 hours * 4 intervals\r\n-            'transformer_labels_count': 48,  # 12 hours ahead\r\n-            'batch_first': True\r\n-        })\r\n+    def _compute_points_per_period(self) -> None:\r\n+        \"\"\"Compute points per period for both input and forecast resolutions.\"\"\"\r\n+        self._input_points_per_period = (\r\n+            60 // self.input_resolution_minutes \r\n+            if self.input_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n+        self._forecast_points_per_period = (\r\n+            60 // self.forecast_resolution_minutes \r\n+            if self.forecast_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n \r\n-    return ModelConfig(**base_config)\n+    def _determine_interval_type(self) -> TimeInterval:\r\n+        \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n+        resolution = self.forecast_resolution_minutes\r\n+        if resolution <= 15:\r\n+            return TimeInterval.FIFTEEN_MIN\r\n+        elif resolution <= 60:\r\n+            return TimeInterval.HOURLY\r\n+        elif resolution <= 1440:  # 24 hours\r\n+            return TimeInterval.DAILY\r\n+        else:\r\n+            return TimeInterval.MONTHLY\r\n+\r\n+    @property\r\n+    def sequence_length(self) -> int:\r\n+        \"\"\"Get total sequence length for model input.\"\"\"\r\n+        if self._input_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        return self.lookback_periods * self._input_points_per_period\r\n+\r\n+    @property\r\n+    def forecast_length(self) -> int:\r\n+        \"\"\"Get total forecast length for model output.\"\"\"\r\n+        if self._forecast_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        return self.forecast_periods * self._forecast_points_per_period\r\n+\r\n+    def needs_resampling(self) -> bool:\r\n+        \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n+        return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n+\r\n+    def get_resampling_factor(self) -> float:\r\n+        \"\"\"Get the factor by which to resample the data.\"\"\"\r\n+        return self.forecast_resolution_minutes / self.input_resolution_minutes\r\n+\r\n+    def get_interval_config(self) -> Optional[IntervalConfig]:\r\n+        \"\"\"Get the interval configuration.\"\"\"\r\n+        return self._interval_config\r\n+\r\n+    def to_dict(self) -> Dict[str, Any]:\r\n+        \"\"\"Convert config to dictionary.\"\"\"\r\n+        base_dict = {\r\n+            'model_type': self.model_type,\r\n+            'input_resolution_minutes': self.input_resolution_minutes,\r\n+            'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n+            'lookback_periods': self.lookback_periods,\r\n+            'forecast_periods': self.forecast_periods,\r\n+            'input_features': self.input_features,\r\n+            'output_features': self.output_features,\r\n+            'd_model': self.d_model,\r\n+            'n_heads': self.n_heads,\r\n+            'n_encoder_layers': self.n_encoder_layers,\r\n+            'n_decoder_layers': self.n_decoder_layers,\r\n+            'd_ff': self.d_ff,\r\n+            'dropout': self.dropout,\r\n+            'value_features': self.value_features,\r\n+            'time_features': self.time_features,\r\n+            'kernel_size': self.kernel_size,\r\n+            'batch_first': self.batch_first,\r\n+            'hidden_dims': self.hidden_dims,\r\n+            'activation': self.activation,\r\n+            'batch_size': self.batch_size,\r\n+            'learning_rate': self.learning_rate,\r\n+            'max_epochs': self.max_epochs,\r\n+            'optimizer': self.optimizer,\r\n+            'criterion': self.criterion,\r\n+            'device': self.device\r\n+        }\r\n+        \r\n+        # Add configuration dictionaries if they're not empty\r\n+        if self.optimizer_config:\r\n+            base_dict['optimizer_config'] = self.optimizer_config\r\n+        if self.scheduler_config:\r\n+            base_dict['scheduler_config'] = self.scheduler_config\r\n+        if self.criterion_config:\r\n+            base_dict['criterion_config'] = self.criterion_config\r\n+            \r\n+        return base_dict\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733134538566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n from dataclasses import dataclass, field\r\n from typing import Dict, Any, Optional, List\r\n from ..registry.model_types import ModelType\r\n-from ...data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n+from ...data_loading.base.interval_types import TimeInterval, IntervalConfig\r\n \r\n @dataclass\r\n class ModelConfig:\r\n     \"\"\"Configuration for model architecture.\"\"\"\r\n"
                },
                {
                    "date": 1733134554318,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n from dataclasses import dataclass, field\r\n from typing import Dict, Any, Optional, List\r\n from ..registry.model_types import ModelType\r\n-from ...data_loading.base.interval_types import TimeInterval, IntervalConfig\r\n+from ...data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n \r\n @dataclass\r\n class ModelConfig:\r\n     \"\"\"Configuration for model architecture.\"\"\"\r\n"
                },
                {
                    "date": 1733134801305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,15 +118,19 @@\n     def sequence_length(self) -> int:\r\n         \"\"\"Get total sequence length for model input.\"\"\"\r\n         if self._input_points_per_period is None:\r\n             self._compute_points_per_period()\r\n+        if self._input_points_per_period is None:  # Double check after computation\r\n+            raise ValueError(\"Input points per period not properly initialized\")\r\n         return self.lookback_periods * self._input_points_per_period\r\n \r\n     @property\r\n     def forecast_length(self) -> int:\r\n         \"\"\"Get total forecast length for model output.\"\"\"\r\n         if self._forecast_points_per_period is None:\r\n             self._compute_points_per_period()\r\n+        if self._forecast_points_per_period is None:  # Double check after computation\r\n+            raise ValueError(\"Forecast points per period not properly initialized\")\r\n         return self.forecast_periods * self._forecast_points_per_period\r\n \r\n     def needs_resampling(self) -> bool:\r\n         \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n@@ -177,5 +181,111 @@\n             base_dict['scheduler_config'] = self.scheduler_config\r\n         if self.criterion_config:\r\n             base_dict['criterion_config'] = self.criterion_config\r\n             \r\n-        return base_dict\n\\ No newline at end of file\n+        return base_dict\r\n+    \r\n+    def get_default_config(\r\n+        model_type: str,\r\n+        input_resolution_minutes: int = 15,\r\n+        forecast_resolution_minutes: int = 15\r\n+    ) -> ModelConfig:\r\n+        \"\"\"Get default configuration for specified model type and resolutions.\r\n+        \r\n+        Args:\r\n+            model_type: Type of model to configure\r\n+            input_resolution_minutes: Resolution of input data in minutes\r\n+            forecast_resolution_minutes: Resolution of forecast in minutes\r\n+        \r\n+        Returns:\r\n+            ModelConfig with appropriate defaults for the specified model type and resolutions\r\n+        \"\"\"\r\n+        # Base configuration common to all models\r\n+        base_config = {\r\n+            'model_type': model_type,\r\n+            'input_resolution_minutes': input_resolution_minutes,\r\n+            'forecast_resolution_minutes': forecast_resolution_minutes,\r\n+            'input_features': 1,\r\n+            'output_features': 1,\r\n+            'value_features': 1,\r\n+            'time_features': None  # Will be computed in post_init\r\n+        }\r\n+\r\n+        # Resolution-specific defaults\r\n+        if forecast_resolution_minutes <= 60:  # Sub-hourly or hourly predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 24,  # 24 periods\r\n+                'forecast_periods': 12,  # 12 periods ahead\r\n+            })\r\n+        elif forecast_resolution_minutes <= 1440:  # Daily predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 7,   # 7 days of history\r\n+                'forecast_periods': 5,   # 5 days ahead\r\n+            })\r\n+        else:  # Monthly predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 12,  # 12 months of history\r\n+                'forecast_periods': 3,   # 3 months ahead\r\n+            })\r\n+\r\n+        # Model-specific configurations\r\n+        if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n+            base_config.update({\r\n+                'd_model': 256,\r\n+                'n_heads': 8,\r\n+                'n_encoder_layers': 4,\r\n+                'n_decoder_layers': 4,\r\n+                'd_ff': 1024,\r\n+                'dropout': 0.2,\r\n+                'kernel_size': 3,\r\n+                'batch_first': True,\r\n+                \r\n+                # Training parameters optimized for time series\r\n+                'batch_size': 32,\r\n+                'learning_rate': 0.001,\r\n+                'max_epochs': 100,\r\n+                'optimizer': 'adamw',\r\n+                'optimizer_config': {\r\n+                    'weight_decay': 0.01,\r\n+                    'betas': (0.9, 0.98)\r\n+                },\r\n+                'scheduler': 'one_cycle',\r\n+                'scheduler_config': {\r\n+                    'pct_start': 0.3,\r\n+                    'div_factor': 25.0,\r\n+                    'final_div_factor': 1000.0\r\n+                }\r\n+            })\r\n+\r\n+            # Resolution-specific model adjustments\r\n+            if forecast_resolution_minutes <= 15:  # Fine-grained predictions\r\n+                base_config.update({\r\n+                    'd_model': 128,  # Smaller model for more frequent data\r\n+                    'n_heads': 4,\r\n+                    'dropout': 0.3,  # More dropout for regularization\r\n+                    'batch_size': 64  # Larger batches for more frequent data\r\n+                })\r\n+            elif forecast_resolution_minutes >= 1440:  # Daily or longer\r\n+                base_config.update({\r\n+                    'd_model': 512,  # Larger model for long-term patterns\r\n+                    'n_heads': 16,\r\n+                    'dropout': 0.1,  # Less dropout for sparse data\r\n+                    'batch_size': 16  # Smaller batches for less frequent data\r\n+                })\r\n+\r\n+        elif model_type == 'simple_neural_net':\r\n+            base_config.update({\r\n+                'hidden_dims': [64, 32],\r\n+                'activation': 'relu',\r\n+                'dropout': 0.1,\r\n+                'batch_size': 32,\r\n+                'learning_rate': 0.001\r\n+            })\r\n+\r\n+        elif model_type == 'linear_regression':\r\n+            base_config.update({\r\n+                'optimizer': 'adam',\r\n+                'learning_rate': 0.01,\r\n+                'batch_size': 64\r\n+            })\r\n+\r\n+        return ModelConfig(**base_config)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733134848362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,13 +183,15 @@\n             base_dict['criterion_config'] = self.criterion_config\r\n             \r\n         return base_dict\r\n     \r\n+    @classmethod\r\n     def get_default_config(\r\n+        cls,\r\n         model_type: str,\r\n         input_resolution_minutes: int = 15,\r\n         forecast_resolution_minutes: int = 15\r\n-    ) -> ModelConfig:\r\n+    ) -> 'ModelConfig':\r\n         \"\"\"Get default configuration for specified model type and resolutions.\r\n         \r\n         Args:\r\n             model_type: Type of model to configure\r\n@@ -287,5 +289,5 @@\n                 'learning_rate': 0.01,\r\n                 'batch_size': 64\r\n             })\r\n \r\n-        return ModelConfig(**base_config)\n\\ No newline at end of file\n+        return cls(**base_config)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733134946670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,290 @@\n+# models/config/model_config.py\r\n+from dataclasses import dataclass, field\r\n+from typing import Dict, Any, Optional, List\r\n+from ..registry.model_types import ModelType\r\n+from ...data_loading.base.interval_types import TimeInterval, IntervalConfig\r\n+\r\n+@dataclass\r\n+class ModelConfig:\r\n+    \"\"\"Configuration for model architecture.\"\"\"\r\n+    # Core model identification\r\n+    model_type: ModelType\r\n+    \r\n+    # Time resolution and sequence configuration\r\n+    input_resolution_minutes: int\r\n+    forecast_resolution_minutes: int\r\n+    lookback_periods: int\r\n+    forecast_periods: int\r\n+    \r\n+    # Model architecture parameters\r\n+    input_features: int\r\n+    output_features: int = 1\r\n+    d_model: int = 512\r\n+    n_heads: int = 8\r\n+    n_encoder_layers: int = 6\r\n+    n_decoder_layers: int = 6\r\n+    d_ff: int = 2048\r\n+    dropout: float = 0.1\r\n+    \r\n+    # Time series specific parameters\r\n+    value_features: int = 1  # Main time series value\r\n+    time_features: Optional[int] = None  # Additional time-based features\r\n+    kernel_size: int = 3  # For convolutional attention\r\n+    batch_first: bool = True  # Handle batch dimension first\r\n+    \r\n+    # Neural network specific\r\n+    hidden_dims: List[int] = field(default_factory=lambda: [64, 32])\r\n+    activation: str = 'relu'\r\n+\r\n+    # Training\r\n+    batch_size: int = 32\r\n+    learning_rate: float = 1e-3\r\n+    max_epochs: int = 100\r\n+    optimizer: str = 'adam'\r\n+    optimizer_config: Dict[str, Any] = field(default_factory=dict)\r\n+    scheduler: Optional[str] = None\r\n+    scheduler_config: Dict[str, Any] = field(default_factory=dict)\r\n+    criterion: str = 'mse'\r\n+    criterion_config: Dict[str, Any] = field(default_factory=dict)\r\n+\r\n+    # Device\r\n+    device: str = 'cuda'\r\n+\r\n+    # Cache for computed values\r\n+    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n+    _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n+    _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n+\r\n+    def __post_init__(self):\r\n+        \"\"\"Post-initialization processing.\"\"\"\r\n+        self._validate_resolutions()\r\n+        self._initialize_interval_config()\r\n+        self._compute_points_per_period()\r\n+        \r\n+        # If time_features not specified, calculate from input features\r\n+        if self.time_features is None:\r\n+            self.time_features = max(0, self.input_features - self.value_features)\r\n+\r\n+    def _validate_resolutions(self) -> None:\r\n+        \"\"\"Validate input and forecast resolutions.\"\"\"\r\n+        # Validate input resolution\r\n+        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate forecast resolution\r\n+        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate that forecast resolution is not finer than input resolution\r\n+        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n+            raise ValueError(\r\n+                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n+                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n+            )\r\n+\r\n+    def _initialize_interval_config(self) -> None:\r\n+        \"\"\"Initialize the interval configuration.\"\"\"\r\n+        self._interval_config = IntervalConfig(\r\n+            interval_type=self._determine_interval_type(),\r\n+            lookback_periods=self.lookback_periods,\r\n+            forecast_periods=self.forecast_periods\r\n+        )\r\n+\r\n+    def _compute_points_per_period(self) -> None:\r\n+        \"\"\"Compute points per period for both input and forecast resolutions.\"\"\"\r\n+        self._input_points_per_period = (\r\n+            60 // self.input_resolution_minutes \r\n+            if self.input_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n+        self._forecast_points_per_period = (\r\n+            60 // self.forecast_resolution_minutes \r\n+            if self.forecast_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n+\r\n+    def _determine_interval_type(self) -> TimeInterval:\r\n+        \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n+        resolution = self.forecast_resolution_minutes\r\n+        if resolution <= 15:\r\n+            return TimeInterval.FIFTEEN_MIN\r\n+        elif resolution <= 60:\r\n+            return TimeInterval.HOURLY\r\n+        elif resolution <= 1440:  # 24 hours\r\n+            return TimeInterval.DAILY\r\n+        else:\r\n+            return TimeInterval.MONTHLY\r\n+\r\n+    @property\r\n+    def sequence_length(self) -> int:\r\n+        \"\"\"Get total sequence length for model input.\"\"\"\r\n+        if self._input_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        return self.lookback_periods * self._input_points_per_period\r\n+\r\n+    @property\r\n+    def forecast_length(self) -> int:\r\n+        \"\"\"Get total forecast length for model output.\"\"\"\r\n+        if self._forecast_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        return self.forecast_periods * self._forecast_points_per_period\r\n+\r\n+    def needs_resampling(self) -> bool:\r\n+        \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n+        return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n+\r\n+    def get_resampling_factor(self) -> float:\r\n+        \"\"\"Get the factor by which to resample the data.\"\"\"\r\n+        return self.forecast_resolution_minutes / self.input_resolution_minutes\r\n+\r\n+    def get_interval_config(self) -> Optional[IntervalConfig]:\r\n+        \"\"\"Get the interval configuration.\"\"\"\r\n+        return self._interval_config\r\n+\r\n+    def to_dict(self) -> Dict[str, Any]:\r\n+        \"\"\"Convert config to dictionary.\"\"\"\r\n+        base_dict = {\r\n+            'model_type': self.model_type,\r\n+            'input_resolution_minutes': self.input_resolution_minutes,\r\n+            'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n+            'lookback_periods': self.lookback_periods,\r\n+            'forecast_periods': self.forecast_periods,\r\n+            'input_features': self.input_features,\r\n+            'output_features': self.output_features,\r\n+            'd_model': self.d_model,\r\n+            'n_heads': self.n_heads,\r\n+            'n_encoder_layers': self.n_encoder_layers,\r\n+            'n_decoder_layers': self.n_decoder_layers,\r\n+            'd_ff': self.d_ff,\r\n+            'dropout': self.dropout,\r\n+            'value_features': self.value_features,\r\n+            'time_features': self.time_features,\r\n+            'kernel_size': self.kernel_size,\r\n+            'batch_first': self.batch_first,\r\n+            'hidden_dims': self.hidden_dims,\r\n+            'activation': self.activation,\r\n+            'batch_size': self.batch_size,\r\n+            'learning_rate': self.learning_rate,\r\n+            'max_epochs': self.max_epochs,\r\n+            'optimizer': self.optimizer,\r\n+            'criterion': self.criterion,\r\n+            'device': self.device\r\n+        }\r\n+        \r\n+        # Add configuration dictionaries if they're not empty\r\n+        if self.optimizer_config:\r\n+            base_dict['optimizer_config'] = self.optimizer_config\r\n+        if self.scheduler_config:\r\n+            base_dict['scheduler_config'] = self.scheduler_config\r\n+        if self.criterion_config:\r\n+            base_dict['criterion_config'] = self.criterion_config\r\n+            \r\n+        return base_dict\r\n+\r\n+    @classmethod\r\n+    def get_default_config(\r\n+        cls,\r\n+        model_type: str,\r\n+        input_resolution_minutes: int = 15,\r\n+        forecast_resolution_minutes: int = 15\r\n+    ) -> 'ModelConfig':\r\n+        \"\"\"Get default configuration for specified model type and resolutions.\r\n+        \r\n+        Args:\r\n+            model_type: Type of model to configure\r\n+            input_resolution_minutes: Resolution of input data in minutes\r\n+            forecast_resolution_minutes: Resolution of forecast in minutes\r\n+        \r\n+        Returns:\r\n+            ModelConfig with appropriate defaults for the specified model type and resolutions\r\n+        \"\"\"\r\n+        # Base configuration common to all models\r\n+        base_config = {\r\n+            'model_type': model_type,\r\n+            'input_resolution_minutes': input_resolution_minutes,\r\n+            'forecast_resolution_minutes': forecast_resolution_minutes,\r\n+            'input_features': 1,\r\n+            'output_features': 1,\r\n+            'value_features': 1,\r\n+            'time_features': None  # Will be computed in post_init\r\n+        }\r\n+\r\n+        # Resolution-specific defaults\r\n+        if forecast_resolution_minutes <= 60:  # Sub-hourly or hourly predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 24,  # 24 periods\r\n+                'forecast_periods': 12,  # 12 periods ahead\r\n+            })\r\n+        elif forecast_resolution_minutes <= 1440:  # Daily predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 7,   # 7 days of history\r\n+                'forecast_periods': 5,   # 5 days ahead\r\n+            })\r\n+        else:  # Monthly predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 12,  # 12 months of history\r\n+                'forecast_periods': 3,   # 3 months ahead\r\n+            })\r\n+\r\n+        # Model-specific configurations\r\n+        if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n+            base_config.update({\r\n+                'd_model': 256,\r\n+                'n_heads': 8,\r\n+                'n_encoder_layers': 4,\r\n+                'n_decoder_layers': 4,\r\n+                'd_ff': 1024,\r\n+                'dropout': 0.2,\r\n+                'kernel_size': 3,\r\n+                'batch_first': True,\r\n+                \r\n+                # Training parameters optimized for time series\r\n+                'batch_size': 32,\r\n+                'learning_rate': 0.001,\r\n+                'max_epochs': 100,\r\n+                'optimizer': 'adamw',\r\n+                'optimizer_config': {\r\n+                    'weight_decay': 0.01,\r\n+                    'betas': (0.9, 0.98)\r\n+                },\r\n+                'scheduler': 'one_cycle',\r\n+                'scheduler_config': {\r\n+                    'pct_start': 0.3,\r\n+                    'div_factor': 25.0,\r\n+                    'final_div_factor': 1000.0\r\n+                }\r\n+            })\r\n+\r\n+            # Resolution-specific model adjustments\r\n+            if forecast_resolution_minutes <= 15:  # Fine-grained predictions\r\n+                base_config.update({\r\n+                    'd_model': 128,  # Smaller model for more frequent data\r\n+                    'n_heads': 4,\r\n+                    'dropout': 0.3,  # More dropout for regularization\r\n+                    'batch_size': 64  # Larger batches for more frequent data\r\n+                })\r\n+            elif forecast_resolution_minutes >= 1440:  # Daily or longer\r\n+                base_config.update({\r\n+                    'd_model': 512,  # Larger model for long-term patterns\r\n+                    'n_heads': 16,\r\n+                    'dropout': 0.1,  # Less dropout for sparse data\r\n+                    'batch_size': 16  # Smaller batches for less frequent data\r\n+                })\r\n+\r\n+        elif model_type == 'simple_neural_net':\r\n+            base_config.update({\r\n+                'hidden_dims': [64, 32],\r\n+                'activation': 'relu',\r\n+                'dropout': 0.1,\r\n+                'batch_size': 32,\r\n+                'learning_rate': 0.001\r\n+            })\r\n+\r\n+        elif model_type == 'linear_regression':\r\n+            base_config.update({\r\n+                'optimizer': 'adam',\r\n+                'learning_rate': 0.01,\r\n+                'batch_size': 64\r\n+            })\r\n+\r\n+        return cls(**base_config)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733135040399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,297 +1,8 @@\n # models/config/model_config.py\r\n from dataclasses import dataclass, field\r\n from typing import Dict, Any, Optional, List\r\n from ..registry.model_types import ModelType\r\n-from ...data_loading.base.interval_types import TimeInterval, IntervalConfig\r\n-\r\n-@dataclass\r\n-class ModelConfig:\r\n-    \"\"\"Configuration for model architecture.\"\"\"\r\n-    # Core model identification\r\n-    model_type: ModelType\r\n-    \r\n-    # Time resolution and sequence configuration\r\n-    input_resolution_minutes: int\r\n-    forecast_resolution_minutes: int\r\n-    lookback_periods: int\r\n-    forecast_periods: int\r\n-    \r\n-    # Model architecture parameters\r\n-    input_features: int\r\n-    output_features: int = 1\r\n-    d_model: int = 512\r\n-    n_heads: int = 8\r\n-    n_encoder_layers: int = 6\r\n-    n_decoder_layers: int = 6\r\n-    d_ff: int = 2048\r\n-    dropout: float = 0.1\r\n-    \r\n-    # Time series specific parameters\r\n-    value_features: int = 1  # Main time series value\r\n-    time_features: Optional[int] = None  # Additional time-based features\r\n-    kernel_size: int = 3  # For convolutional attention\r\n-    batch_first: bool = True  # Handle batch dimension first\r\n-    \r\n-    # Neural network specific\r\n-    hidden_dims: List[int] = field(default_factory=lambda: [64, 32])\r\n-    activation: str = 'relu'\r\n-\r\n-    # Training\r\n-    batch_size: int = 32\r\n-    learning_rate: float = 1e-3\r\n-    max_epochs: int = 100\r\n-    optimizer: str = 'adam'\r\n-    optimizer_config: Dict[str, Any] = field(default_factory=dict)\r\n-    scheduler: Optional[str] = None\r\n-    scheduler_config: Dict[str, Any] = field(default_factory=dict)\r\n-    criterion: str = 'mse'\r\n-    criterion_config: Dict[str, Any] = field(default_factory=dict)\r\n-\r\n-    # Device\r\n-    device: str = 'cuda'\r\n-\r\n-    # Cache for computed values\r\n-    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n-    _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n-    _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n-\r\n-    def __post_init__(self):\r\n-        \"\"\"Post-initialization processing.\"\"\"\r\n-        self._validate_resolutions()\r\n-        self._initialize_interval_config()\r\n-        self._compute_points_per_period()\r\n-        \r\n-        # If time_features not specified, calculate from input features\r\n-        if self.time_features is None:\r\n-            self.time_features = max(0, self.input_features - self.value_features)\r\n-\r\n-    def _validate_resolutions(self) -> None:\r\n-        \"\"\"Validate input and forecast resolutions.\"\"\"\r\n-        # Validate input resolution\r\n-        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n-            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n-            \r\n-        # Validate forecast resolution\r\n-        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n-            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n-            \r\n-        # Validate that forecast resolution is not finer than input resolution\r\n-        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n-            raise ValueError(\r\n-                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n-                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n-            )\r\n-\r\n-    def _initialize_interval_config(self) -> None:\r\n-        \"\"\"Initialize the interval configuration.\"\"\"\r\n-        self._interval_config = IntervalConfig(\r\n-            interval_type=self._determine_interval_type(),\r\n-            lookback_periods=self.lookback_periods,\r\n-            forecast_periods=self.forecast_periods\r\n-        )\r\n-\r\n-    def _compute_points_per_period(self) -> None:\r\n-        \"\"\"Compute points per period for both input and forecast resolutions.\"\"\"\r\n-        self._input_points_per_period = (\r\n-            60 // self.input_resolution_minutes \r\n-            if self.input_resolution_minutes <= 60 \r\n-            else 1\r\n-        )\r\n-        self._forecast_points_per_period = (\r\n-            60 // self.forecast_resolution_minutes \r\n-            if self.forecast_resolution_minutes <= 60 \r\n-            else 1\r\n-        )\r\n-\r\n-    def _determine_interval_type(self) -> TimeInterval:\r\n-        \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n-        resolution = self.forecast_resolution_minutes\r\n-        if resolution <= 15:\r\n-            return TimeInterval.FIFTEEN_MIN\r\n-        elif resolution <= 60:\r\n-            return TimeInterval.HOURLY\r\n-        elif resolution <= 1440:  # 24 hours\r\n-            return TimeInterval.DAILY\r\n-        else:\r\n-            return TimeInterval.MONTHLY\r\n-\r\n-    @property\r\n-    def sequence_length(self) -> int:\r\n-        \"\"\"Get total sequence length for model input.\"\"\"\r\n-        if self._input_points_per_period is None:\r\n-            self._compute_points_per_period()\r\n-        return self.lookback_periods * self._input_points_per_period\r\n-\r\n-    @property\r\n-    def forecast_length(self) -> int:\r\n-        \"\"\"Get total forecast length for model output.\"\"\"\r\n-        if self._forecast_points_per_period is None:\r\n-            self._compute_points_per_period()\r\n-        return self.forecast_periods * self._forecast_points_per_period\r\n-\r\n-    def needs_resampling(self) -> bool:\r\n-        \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n-        return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n-\r\n-    def get_resampling_factor(self) -> float:\r\n-        \"\"\"Get the factor by which to resample the data.\"\"\"\r\n-        return self.forecast_resolution_minutes / self.input_resolution_minutes\r\n-\r\n-    def get_interval_config(self) -> Optional[IntervalConfig]:\r\n-        \"\"\"Get the interval configuration.\"\"\"\r\n-        return self._interval_config\r\n-\r\n-    def to_dict(self) -> Dict[str, Any]:\r\n-        \"\"\"Convert config to dictionary.\"\"\"\r\n-        base_dict = {\r\n-            'model_type': self.model_type,\r\n-            'input_resolution_minutes': self.input_resolution_minutes,\r\n-            'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n-            'lookback_periods': self.lookback_periods,\r\n-            'forecast_periods': self.forecast_periods,\r\n-            'input_features': self.input_features,\r\n-            'output_features': self.output_features,\r\n-            'd_model': self.d_model,\r\n-            'n_heads': self.n_heads,\r\n-            'n_encoder_layers': self.n_encoder_layers,\r\n-            'n_decoder_layers': self.n_decoder_layers,\r\n-            'd_ff': self.d_ff,\r\n-            'dropout': self.dropout,\r\n-            'value_features': self.value_features,\r\n-            'time_features': self.time_features,\r\n-            'kernel_size': self.kernel_size,\r\n-            'batch_first': self.batch_first,\r\n-            'hidden_dims': self.hidden_dims,\r\n-            'activation': self.activation,\r\n-            'batch_size': self.batch_size,\r\n-            'learning_rate': self.learning_rate,\r\n-            'max_epochs': self.max_epochs,\r\n-            'optimizer': self.optimizer,\r\n-            'criterion': self.criterion,\r\n-            'device': self.device\r\n-        }\r\n-        \r\n-        # Add configuration dictionaries if they're not empty\r\n-        if self.optimizer_config:\r\n-            base_dict['optimizer_config'] = self.optimizer_config\r\n-        if self.scheduler_config:\r\n-            base_dict['scheduler_config'] = self.scheduler_config\r\n-        if self.criterion_config:\r\n-            base_dict['criterion_config'] = self.criterion_config\r\n-            \r\n-        return base_dict\r\n-\r\n-    @classmethod\r\n-    def get_default_config(\r\n-        cls,\r\n-        model_type: str,\r\n-        input_resolution_minutes: int = 15,\r\n-        forecast_resolution_minutes: int = 15\r\n-    ) -> 'ModelConfig':\r\n-        \"\"\"Get default configuration for specified model type and resolutions.\r\n-        \r\n-        Args:\r\n-            model_type: Type of model to configure\r\n-            input_resolution_minutes: Resolution of input data in minutes\r\n-            forecast_resolution_minutes: Resolution of forecast in minutes\r\n-        \r\n-        Returns:\r\n-            ModelConfig with appropriate defaults for the specified model type and resolutions\r\n-        \"\"\"\r\n-        # Base configuration common to all models\r\n-        base_config = {\r\n-            'model_type': model_type,\r\n-            'input_resolution_minutes': input_resolution_minutes,\r\n-            'forecast_resolution_minutes': forecast_resolution_minutes,\r\n-            'input_features': 1,\r\n-            'output_features': 1,\r\n-            'value_features': 1,\r\n-            'time_features': None  # Will be computed in post_init\r\n-        }\r\n-\r\n-        # Resolution-specific defaults\r\n-        if forecast_resolution_minutes <= 60:  # Sub-hourly or hourly predictions\r\n-            base_config.update({\r\n-                'lookback_periods': 24,  # 24 periods\r\n-                'forecast_periods': 12,  # 12 periods ahead\r\n-            })\r\n-        elif forecast_resolution_minutes <= 1440:  # Daily predictions\r\n-            base_config.update({\r\n-                'lookback_periods': 7,   # 7 days of history\r\n-                'forecast_periods': 5,   # 5 days ahead\r\n-            })\r\n-        else:  # Monthly predictions\r\n-            base_config.update({\r\n-                'lookback_periods': 12,  # 12 months of history\r\n-                'forecast_periods': 3,   # 3 months ahead\r\n-            })\r\n-\r\n-        # Model-specific configurations\r\n-        if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n-            base_config.update({\r\n-                'd_model': 256,\r\n-                'n_heads': 8,\r\n-                'n_encoder_layers': 4,\r\n-                'n_decoder_layers': 4,\r\n-                'd_ff': 1024,\r\n-                'dropout': 0.2,\r\n-                'kernel_size': 3,\r\n-                'batch_first': True,\r\n-                \r\n-                # Training parameters optimized for time series\r\n-                'batch_size': 32,\r\n-                'learning_rate': 0.001,\r\n-                'max_epochs': 100,\r\n-                'optimizer': 'adamw',\r\n-                'optimizer_config': {\r\n-                    'weight_decay': 0.01,\r\n-                    'betas': (0.9, 0.98)\r\n-                },\r\n-                'scheduler': 'one_cycle',\r\n-                'scheduler_config': {\r\n-                    'pct_start': 0.3,\r\n-                    'div_factor': 25.0,\r\n-                    'final_div_factor': 1000.0\r\n-                }\r\n-            })\r\n-\r\n-            # Resolution-specific model adjustments\r\n-            if forecast_resolution_minutes <= 15:  # Fine-grained predictions\r\n-                base_config.update({\r\n-                    'd_model': 128,  # Smaller model for more frequent data\r\n-                    'n_heads': 4,\r\n-                    'dropout': 0.3,  # More dropout for regularization\r\n-                    'batch_size': 64  # Larger batches for more frequent data\r\n-                })\r\n-            elif forecast_resolution_minutes >= 1440:  # Daily or longer\r\n-                base_config.update({\r\n-                    'd_model': 512,  # Larger model for long-term patterns\r\n-                    'n_heads': 16,\r\n-                    'dropout': 0.1,  # Less dropout for sparse data\r\n-                    'batch_size': 16  # Smaller batches for less frequent data\r\n-                })\r\n-\r\n-        elif model_type == 'simple_neural_net':\r\n-            base_config.update({\r\n-                'hidden_dims': [64, 32],\r\n-                'activation': 'relu',\r\n-                'dropout': 0.1,\r\n-                'batch_size': 32,\r\n-                'learning_rate': 0.001\r\n-            })\r\n-\r\n-        elif model_type == 'linear_regression':\r\n-            base_config.update({\r\n-                'optimizer': 'adam',\r\n-                'learning_rate': 0.01,\r\n-                'batch_size': 64\r\n-            })\r\n-\r\n-        return cls(**base_config)\n-from dataclasses import dataclass, field\r\n-from typing import Dict, Any, Optional, List\r\n-from ..registry.model_types import ModelType\r\n from ...data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n \r\n @dataclass\r\n class ModelConfig:\r\n@@ -408,18 +119,18 @@\n     def sequence_length(self) -> int:\r\n         \"\"\"Get total sequence length for model input.\"\"\"\r\n         if self._input_points_per_period is None:\r\n             self._compute_points_per_period()\r\n-        if self._input_points_per_period is None:  # Double check after computation\r\n+        if self._input_points_per_period is None:  # double-check after computation\r\n             raise ValueError(\"Input points per period not properly initialized\")\r\n         return self.lookback_periods * self._input_points_per_period\r\n \r\n     @property\r\n     def forecast_length(self) -> int:\r\n         \"\"\"Get total forecast length for model output.\"\"\"\r\n         if self._forecast_points_per_period is None:\r\n             self._compute_points_per_period()\r\n-        if self._forecast_points_per_period is None:  # Double check after computation\r\n+        if self._forecast_points_per_period is None:  # double-check after computation\r\n             raise ValueError(\"Forecast points per period not properly initialized\")\r\n         return self.forecast_periods * self._forecast_points_per_period\r\n \r\n     def needs_resampling(self) -> bool:\r\n@@ -472,9 +183,9 @@\n         if self.criterion_config:\r\n             base_dict['criterion_config'] = self.criterion_config\r\n             \r\n         return base_dict\r\n-    \r\n+\r\n     @classmethod\r\n     def get_default_config(\r\n         cls,\r\n         model_type: str,\r\n"
                },
                {
                    "date": 1733178950676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n # models/config/model_config.py\r\n from dataclasses import dataclass, field\r\n from typing import Dict, Any, Optional, List\r\n-from ..registry.model_types import ModelType\r\n-from ...data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n+from models.registry.model_types import ModelType\r\n+from data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n \r\n @dataclass\r\n class ModelConfig:\r\n     \"\"\"Configuration for model architecture.\"\"\"\r\n"
                },
                {
                    "date": 1733180384492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n @dataclass\r\n class ModelConfig:\r\n     \"\"\"Configuration for model architecture.\"\"\"\r\n     # Core model identification\r\n-    model_type: ModelType\r\n+    model_type: ModelType  # Make sure this is ModelType, not str\r\n     \r\n     # Time resolution and sequence configuration\r\n     input_resolution_minutes: int\r\n     forecast_resolution_minutes: int\r\n@@ -147,9 +147,9 @@\n \r\n     def to_dict(self) -> Dict[str, Any]:\r\n         \"\"\"Convert config to dictionary.\"\"\"\r\n         base_dict = {\r\n-            'model_type': self.model_type,\r\n+            'model_type': str(self.model_type),  # Convert to string only for serialization\r\n             'input_resolution_minutes': self.input_resolution_minutes,\r\n             'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n             'lookback_periods': self.lookback_periods,\r\n             'forecast_periods': self.forecast_periods,\r\n@@ -187,9 +187,9 @@\n \r\n     @classmethod\r\n     def get_default_config(\r\n         cls,\r\n-        model_type: str,\r\n+        model_type: ModelType,  # Change parameter type to ModelType\r\n         input_resolution_minutes: int = 15,\r\n         forecast_resolution_minutes: int = 15\r\n     ) -> 'ModelConfig':\r\n         \"\"\"Get default configuration for specified model type and resolutions.\r\n@@ -203,9 +203,9 @@\n             ModelConfig with appropriate defaults for the specified model type and resolutions\r\n         \"\"\"\r\n         # Base configuration common to all models\r\n         base_config = {\r\n-            'model_type': model_type,\r\n+            'model_type': model_type,  # Pass ModelType enum directly\r\n             'input_resolution_minutes': input_resolution_minutes,\r\n             'forecast_resolution_minutes': forecast_resolution_minutes,\r\n             'input_features': 1,\r\n             'output_features': 1,\r\n"
                },
                {
                    "date": 1733180517885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n @dataclass\r\n class ModelConfig:\r\n     \"\"\"Configuration for model architecture.\"\"\"\r\n     # Core model identification\r\n-    model_type: ModelType  # Make sure this is ModelType, not str\r\n+    model_type: ModelType\r\n     \r\n     # Time resolution and sequence configuration\r\n     input_resolution_minutes: int\r\n     forecast_resolution_minutes: int\r\n@@ -147,9 +147,9 @@\n \r\n     def to_dict(self) -> Dict[str, Any]:\r\n         \"\"\"Convert config to dictionary.\"\"\"\r\n         base_dict = {\r\n-            'model_type': str(self.model_type),  # Convert to string only for serialization\r\n+            'model_type': self.model_type,\r\n             'input_resolution_minutes': self.input_resolution_minutes,\r\n             'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n             'lookback_periods': self.lookback_periods,\r\n             'forecast_periods': self.forecast_periods,\r\n@@ -187,9 +187,9 @@\n \r\n     @classmethod\r\n     def get_default_config(\r\n         cls,\r\n-        model_type: ModelType,  # Change parameter type to ModelType\r\n+        model_type: ModelType,  # Changed from str to ModelType\r\n         input_resolution_minutes: int = 15,\r\n         forecast_resolution_minutes: int = 15\r\n     ) -> 'ModelConfig':\r\n         \"\"\"Get default configuration for specified model type and resolutions.\r\n"
                },
                {
                    "date": 1733236106593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,18 +15,22 @@\n     forecast_resolution_minutes: int\r\n     lookback_periods: int\r\n     forecast_periods: int\r\n     \r\n+    \r\n     # Model architecture parameters\r\n     input_features: int\r\n+    \r\n     output_features: int = 1\r\n     d_model: int = 512\r\n     n_heads: int = 8\r\n     n_encoder_layers: int = 6\r\n     n_decoder_layers: int = 6\r\n     d_ff: int = 2048\r\n     dropout: float = 0.1\r\n     \r\n+    max_sequence_length: int = 5000\r\n+    \r\n     # Time series specific parameters\r\n     value_features: int = 1  # Main time series value\r\n     time_features: Optional[int] = None  # Additional time-based features\r\n     kernel_size: int = 3  # For convolutional attention\r\n"
                },
                {
                    "date": 1733238178064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,12 +59,14 @@\n     _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n     _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n \r\n     def __post_init__(self):\r\n-        \"\"\"Post-initialization processing.\"\"\"\r\n+        \"\"\"Post-initialization processing with enhanced feature validation.\"\"\"\r\n         self._validate_resolutions()\r\n+        self._validate_features()  # Add this line\r\n         self._initialize_interval_config()\r\n         self._compute_points_per_period()\r\n+\r\n         \r\n         # If time_features not specified, calculate from input features\r\n         if self.time_features is None:\r\n             self.time_features = max(0, self.input_features - self.value_features)\r\n"
                },
                {
                    "date": 1733238190866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,312 @@\n+# models/config/model_config.py\r\n+from dataclasses import dataclass, field\r\n+from typing import Dict, Any, Optional, List\r\n+from models.registry.model_types import ModelType\r\n+from data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n+\r\n+@dataclass\r\n+class ModelConfig:\r\n+    \"\"\"Configuration for model architecture.\"\"\"\r\n+    # Core model identification\r\n+    model_type: ModelType\r\n+    \r\n+    # Time resolution and sequence configuration\r\n+    input_resolution_minutes: int\r\n+    forecast_resolution_minutes: int\r\n+    lookback_periods: int\r\n+    forecast_periods: int\r\n+    \r\n+    \r\n+    # Model architecture parameters\r\n+    input_features: int\r\n+    \r\n+    output_features: int = 1\r\n+    d_model: int = 512\r\n+    n_heads: int = 8\r\n+    n_encoder_layers: int = 6\r\n+    n_decoder_layers: int = 6\r\n+    d_ff: int = 2048\r\n+    dropout: float = 0.1\r\n+    \r\n+    max_sequence_length: int = 5000\r\n+    \r\n+    # Time series specific parameters\r\n+    value_features: int = 1  # Main time series value\r\n+    time_features: Optional[int] = None  # Additional time-based features\r\n+    kernel_size: int = 3  # For convolutional attention\r\n+    batch_first: bool = True  # Handle batch dimension first\r\n+    \r\n+    # Neural network specific\r\n+    hidden_dims: List[int] = field(default_factory=lambda: [64, 32])\r\n+    activation: str = 'relu'\r\n+\r\n+    # Training\r\n+    batch_size: int = 32\r\n+    learning_rate: float = 1e-3\r\n+    max_epochs: int = 100\r\n+    optimizer: str = 'adam'\r\n+    optimizer_config: Dict[str, Any] = field(default_factory=dict)\r\n+    scheduler: Optional[str] = None\r\n+    scheduler_config: Dict[str, Any] = field(default_factory=dict)\r\n+    criterion: str = 'mse'\r\n+    criterion_config: Dict[str, Any] = field(default_factory=dict)\r\n+\r\n+    # Device\r\n+    device: str = 'cuda'\r\n+\r\n+    # Cache for computed values\r\n+    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n+    _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n+    _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n+\r\n+    def __post_init__(self):\r\n+        \"\"\"Post-initialization processing with enhanced feature validation.\"\"\"\r\n+        self._validate_resolutions()\r\n+        self._validate_features()  # Add this line\r\n+        self._initialize_interval_config()\r\n+        self._compute_points_per_period()\r\n+\r\n+        \r\n+        # If time_features not specified, calculate from input features\r\n+        if self.time_features is None:\r\n+            self.time_features = max(0, self.input_features - self.value_features)\r\n+            \r\n+    def _validate_features(self) -> None:\r\n+            \"\"\"Validate feature dimensions.\"\"\"\r\n+            if self.time_features is None:\r\n+                self.time_features = self.input_features - self.value_features\r\n+                \r\n+            total_features = self.value_features + self.time_features\r\n+            if total_features != self.input_features:\r\n+                raise ValueError(\r\n+                    f\"Feature dimension mismatch! Total features ({self.input_features}) must equal \"\r\n+                    f\"value_features ({self.value_features}) + time_features ({self.time_features})\"\r\n+                )\r\n+\r\n+    def _validate_resolutions(self) -> None:\r\n+        \"\"\"Validate input and forecast resolutions.\"\"\"\r\n+        # Validate input resolution\r\n+        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate forecast resolution\r\n+        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n+            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n+            \r\n+        # Validate that forecast resolution is not finer than input resolution\r\n+        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n+            raise ValueError(\r\n+                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n+                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n+            )\r\n+\r\n+    def _initialize_interval_config(self) -> None:\r\n+        \"\"\"Initialize the interval configuration.\"\"\"\r\n+        self._interval_config = IntervalConfig(\r\n+            interval_type=self._determine_interval_type(),\r\n+            lookback_periods=self.lookback_periods,\r\n+            forecast_periods=self.forecast_periods\r\n+        )\r\n+\r\n+    def _compute_points_per_period(self) -> None:\r\n+        \"\"\"Compute points per period for both input and forecast resolutions.\"\"\"\r\n+        self._input_points_per_period = (\r\n+            60 // self.input_resolution_minutes \r\n+            if self.input_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n+        self._forecast_points_per_period = (\r\n+            60 // self.forecast_resolution_minutes \r\n+            if self.forecast_resolution_minutes <= 60 \r\n+            else 1\r\n+        )\r\n+\r\n+    def _determine_interval_type(self) -> TimeInterval:\r\n+        \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n+        resolution = self.forecast_resolution_minutes\r\n+        if resolution <= 15:\r\n+            return TimeInterval.FIFTEEN_MIN\r\n+        elif resolution <= 60:\r\n+            return TimeInterval.HOURLY\r\n+        elif resolution <= 1440:  # 24 hours\r\n+            return TimeInterval.DAILY\r\n+        else:\r\n+            return TimeInterval.MONTHLY\r\n+\r\n+    @property\r\n+    def sequence_length(self) -> int:\r\n+        \"\"\"Get total sequence length for model input.\"\"\"\r\n+        if self._input_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        if self._input_points_per_period is None:  # double-check after computation\r\n+            raise ValueError(\"Input points per period not properly initialized\")\r\n+        return self.lookback_periods * self._input_points_per_period\r\n+\r\n+    @property\r\n+    def forecast_length(self) -> int:\r\n+        \"\"\"Get total forecast length for model output.\"\"\"\r\n+        if self._forecast_points_per_period is None:\r\n+            self._compute_points_per_period()\r\n+        if self._forecast_points_per_period is None:  # double-check after computation\r\n+            raise ValueError(\"Forecast points per period not properly initialized\")\r\n+        return self.forecast_periods * self._forecast_points_per_period\r\n+\r\n+    def needs_resampling(self) -> bool:\r\n+        \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n+        return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n+\r\n+    def get_resampling_factor(self) -> float:\r\n+        \"\"\"Get the factor by which to resample the data.\"\"\"\r\n+        return self.forecast_resolution_minutes / self.input_resolution_minutes\r\n+\r\n+    def get_interval_config(self) -> Optional[IntervalConfig]:\r\n+        \"\"\"Get the interval configuration.\"\"\"\r\n+        return self._interval_config\r\n+\r\n+    def to_dict(self) -> Dict[str, Any]:\r\n+        \"\"\"Convert config to dictionary.\"\"\"\r\n+        base_dict = {\r\n+            'model_type': self.model_type,\r\n+            'input_resolution_minutes': self.input_resolution_minutes,\r\n+            'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n+            'lookback_periods': self.lookback_periods,\r\n+            'forecast_periods': self.forecast_periods,\r\n+            'input_features': self.input_features,\r\n+            'output_features': self.output_features,\r\n+            'd_model': self.d_model,\r\n+            'n_heads': self.n_heads,\r\n+            'n_encoder_layers': self.n_encoder_layers,\r\n+            'n_decoder_layers': self.n_decoder_layers,\r\n+            'd_ff': self.d_ff,\r\n+            'dropout': self.dropout,\r\n+            'value_features': self.value_features,\r\n+            'time_features': self.time_features,\r\n+            'kernel_size': self.kernel_size,\r\n+            'batch_first': self.batch_first,\r\n+            'hidden_dims': self.hidden_dims,\r\n+            'activation': self.activation,\r\n+            'batch_size': self.batch_size,\r\n+            'learning_rate': self.learning_rate,\r\n+            'max_epochs': self.max_epochs,\r\n+            'optimizer': self.optimizer,\r\n+            'criterion': self.criterion,\r\n+            'device': self.device\r\n+        }\r\n+        \r\n+        # Add configuration dictionaries if they're not empty\r\n+        if self.optimizer_config:\r\n+            base_dict['optimizer_config'] = self.optimizer_config\r\n+        if self.scheduler_config:\r\n+            base_dict['scheduler_config'] = self.scheduler_config\r\n+        if self.criterion_config:\r\n+            base_dict['criterion_config'] = self.criterion_config\r\n+            \r\n+        return base_dict\r\n+\r\n+    @classmethod\r\n+    def get_default_config(\r\n+        cls,\r\n+        model_type: ModelType,  # Changed from str to ModelType\r\n+        input_resolution_minutes: int = 15,\r\n+        forecast_resolution_minutes: int = 15\r\n+    ) -> 'ModelConfig':\r\n+        \"\"\"Get default configuration for specified model type and resolutions.\r\n+        \r\n+        Args:\r\n+            model_type: Type of model to configure\r\n+            input_resolution_minutes: Resolution of input data in minutes\r\n+            forecast_resolution_minutes: Resolution of forecast in minutes\r\n+        \r\n+        Returns:\r\n+            ModelConfig with appropriate defaults for the specified model type and resolutions\r\n+        \"\"\"\r\n+        # Base configuration common to all models\r\n+        base_config = {\r\n+            'model_type': model_type,  # Pass ModelType enum directly\r\n+            'input_resolution_minutes': input_resolution_minutes,\r\n+            'forecast_resolution_minutes': forecast_resolution_minutes,\r\n+            'input_features': 1,\r\n+            'output_features': 1,\r\n+            'value_features': 1,\r\n+            'time_features': None  # Will be computed in post_init\r\n+        }\r\n+\r\n+        # Resolution-specific defaults\r\n+        if forecast_resolution_minutes <= 60:  # Sub-hourly or hourly predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 24,  # 24 periods\r\n+                'forecast_periods': 12,  # 12 periods ahead\r\n+            })\r\n+        elif forecast_resolution_minutes <= 1440:  # Daily predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 7,   # 7 days of history\r\n+                'forecast_periods': 5,   # 5 days ahead\r\n+            })\r\n+        else:  # Monthly predictions\r\n+            base_config.update({\r\n+                'lookback_periods': 12,  # 12 months of history\r\n+                'forecast_periods': 3,   # 3 months ahead\r\n+            })\r\n+\r\n+        # Model-specific configurations\r\n+        if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n+            base_config.update({\r\n+                'd_model': 256,\r\n+                'n_heads': 8,\r\n+                'n_encoder_layers': 4,\r\n+                'n_decoder_layers': 4,\r\n+                'd_ff': 1024,\r\n+                'dropout': 0.2,\r\n+                'kernel_size': 3,\r\n+                'batch_first': True,\r\n+                \r\n+                # Training parameters optimized for time series\r\n+                'batch_size': 32,\r\n+                'learning_rate': 0.001,\r\n+                'max_epochs': 100,\r\n+                'optimizer': 'adamw',\r\n+                'optimizer_config': {\r\n+                    'weight_decay': 0.01,\r\n+                    'betas': (0.9, 0.98)\r\n+                },\r\n+                'scheduler': 'one_cycle',\r\n+                'scheduler_config': {\r\n+                    'pct_start': 0.3,\r\n+                    'div_factor': 25.0,\r\n+                    'final_div_factor': 1000.0\r\n+                }\r\n+            })\r\n+\r\n+            # Resolution-specific model adjustments\r\n+            if forecast_resolution_minutes <= 15:  # Fine-grained predictions\r\n+                base_config.update({\r\n+                    'd_model': 128,  # Smaller model for more frequent data\r\n+                    'n_heads': 4,\r\n+                    'dropout': 0.3,  # More dropout for regularization\r\n+                    'batch_size': 64  # Larger batches for more frequent data\r\n+                })\r\n+            elif forecast_resolution_minutes >= 1440:  # Daily or longer\r\n+                base_config.update({\r\n+                    'd_model': 512,  # Larger model for long-term patterns\r\n+                    'n_heads': 16,\r\n+                    'dropout': 0.1,  # Less dropout for sparse data\r\n+                    'batch_size': 16  # Smaller batches for less frequent data\r\n+                })\r\n+\r\n+        elif model_type == 'simple_neural_net':\r\n+            base_config.update({\r\n+                'hidden_dims': [64, 32],\r\n+                'activation': 'relu',\r\n+                'dropout': 0.1,\r\n+                'batch_size': 32,\r\n+                'learning_rate': 0.001\r\n+            })\r\n+\r\n+        elif model_type == 'linear_regression':\r\n+            base_config.update({\r\n+                'optimizer': 'adam',\r\n+                'learning_rate': 0.01,\r\n+                'batch_size': 64\r\n+            })\r\n+\r\n+        return cls(**base_config)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733238198229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -308,305 +308,5 @@\n                 'learning_rate': 0.01,\r\n                 'batch_size': 64\r\n             })\r\n \r\n-        return cls(**base_config)\n-# models/config/model_config.py\r\n-from dataclasses import dataclass, field\r\n-from typing import Dict, Any, Optional, List\r\n-from models.registry.model_types import ModelType\r\n-from data_loading.types.interval_types import TimeInterval, IntervalConfig\r\n-\r\n-@dataclass\r\n-class ModelConfig:\r\n-    \"\"\"Configuration for model architecture.\"\"\"\r\n-    # Core model identification\r\n-    model_type: ModelType\r\n-    \r\n-    # Time resolution and sequence configuration\r\n-    input_resolution_minutes: int\r\n-    forecast_resolution_minutes: int\r\n-    lookback_periods: int\r\n-    forecast_periods: int\r\n-    \r\n-    \r\n-    # Model architecture parameters\r\n-    input_features: int\r\n-    \r\n-    output_features: int = 1\r\n-    d_model: int = 512\r\n-    n_heads: int = 8\r\n-    n_encoder_layers: int = 6\r\n-    n_decoder_layers: int = 6\r\n-    d_ff: int = 2048\r\n-    dropout: float = 0.1\r\n-    \r\n-    max_sequence_length: int = 5000\r\n-    \r\n-    # Time series specific parameters\r\n-    value_features: int = 1  # Main time series value\r\n-    time_features: Optional[int] = None  # Additional time-based features\r\n-    kernel_size: int = 3  # For convolutional attention\r\n-    batch_first: bool = True  # Handle batch dimension first\r\n-    \r\n-    # Neural network specific\r\n-    hidden_dims: List[int] = field(default_factory=lambda: [64, 32])\r\n-    activation: str = 'relu'\r\n-\r\n-    # Training\r\n-    batch_size: int = 32\r\n-    learning_rate: float = 1e-3\r\n-    max_epochs: int = 100\r\n-    optimizer: str = 'adam'\r\n-    optimizer_config: Dict[str, Any] = field(default_factory=dict)\r\n-    scheduler: Optional[str] = None\r\n-    scheduler_config: Dict[str, Any] = field(default_factory=dict)\r\n-    criterion: str = 'mse'\r\n-    criterion_config: Dict[str, Any] = field(default_factory=dict)\r\n-\r\n-    # Device\r\n-    device: str = 'cuda'\r\n-\r\n-    # Cache for computed values\r\n-    _interval_config: Optional[IntervalConfig] = field(init=False, default=None)\r\n-    _input_points_per_period: Optional[int] = field(init=False, default=None)\r\n-    _forecast_points_per_period: Optional[int] = field(init=False, default=None)\r\n-\r\n-    def __post_init__(self):\r\n-        \"\"\"Post-initialization processing with enhanced feature validation.\"\"\"\r\n-        self._validate_resolutions()\r\n-        self._validate_features()  # Add this line\r\n-        self._initialize_interval_config()\r\n-        self._compute_points_per_period()\r\n-\r\n-        \r\n-        # If time_features not specified, calculate from input features\r\n-        if self.time_features is None:\r\n-            self.time_features = max(0, self.input_features - self.value_features)\r\n-\r\n-    def _validate_resolutions(self) -> None:\r\n-        \"\"\"Validate input and forecast resolutions.\"\"\"\r\n-        # Validate input resolution\r\n-        if 60 % self.input_resolution_minutes != 0 and self.input_resolution_minutes % 60 != 0:\r\n-            raise ValueError(f\"Invalid input resolution: {self.input_resolution_minutes} minutes\")\r\n-            \r\n-        # Validate forecast resolution\r\n-        if 60 % self.forecast_resolution_minutes != 0 and self.forecast_resolution_minutes % 60 != 0:\r\n-            raise ValueError(f\"Invalid forecast resolution: {self.forecast_resolution_minutes} minutes\")\r\n-            \r\n-        # Validate that forecast resolution is not finer than input resolution\r\n-        if self.forecast_resolution_minutes < self.input_resolution_minutes:\r\n-            raise ValueError(\r\n-                f\"Forecast resolution ({self.forecast_resolution_minutes} min) cannot be finer than \"\r\n-                f\"input resolution ({self.input_resolution_minutes} min)\"\r\n-            )\r\n-\r\n-    def _initialize_interval_config(self) -> None:\r\n-        \"\"\"Initialize the interval configuration.\"\"\"\r\n-        self._interval_config = IntervalConfig(\r\n-            interval_type=self._determine_interval_type(),\r\n-            lookback_periods=self.lookback_periods,\r\n-            forecast_periods=self.forecast_periods\r\n-        )\r\n-\r\n-    def _compute_points_per_period(self) -> None:\r\n-        \"\"\"Compute points per period for both input and forecast resolutions.\"\"\"\r\n-        self._input_points_per_period = (\r\n-            60 // self.input_resolution_minutes \r\n-            if self.input_resolution_minutes <= 60 \r\n-            else 1\r\n-        )\r\n-        self._forecast_points_per_period = (\r\n-            60 // self.forecast_resolution_minutes \r\n-            if self.forecast_resolution_minutes <= 60 \r\n-            else 1\r\n-        )\r\n-\r\n-    def _determine_interval_type(self) -> TimeInterval:\r\n-        \"\"\"Determine the interval type based on forecast resolution.\"\"\"\r\n-        resolution = self.forecast_resolution_minutes\r\n-        if resolution <= 15:\r\n-            return TimeInterval.FIFTEEN_MIN\r\n-        elif resolution <= 60:\r\n-            return TimeInterval.HOURLY\r\n-        elif resolution <= 1440:  # 24 hours\r\n-            return TimeInterval.DAILY\r\n-        else:\r\n-            return TimeInterval.MONTHLY\r\n-\r\n-    @property\r\n-    def sequence_length(self) -> int:\r\n-        \"\"\"Get total sequence length for model input.\"\"\"\r\n-        if self._input_points_per_period is None:\r\n-            self._compute_points_per_period()\r\n-        if self._input_points_per_period is None:  # double-check after computation\r\n-            raise ValueError(\"Input points per period not properly initialized\")\r\n-        return self.lookback_periods * self._input_points_per_period\r\n-\r\n-    @property\r\n-    def forecast_length(self) -> int:\r\n-        \"\"\"Get total forecast length for model output.\"\"\"\r\n-        if self._forecast_points_per_period is None:\r\n-            self._compute_points_per_period()\r\n-        if self._forecast_points_per_period is None:  # double-check after computation\r\n-            raise ValueError(\"Forecast points per period not properly initialized\")\r\n-        return self.forecast_periods * self._forecast_points_per_period\r\n-\r\n-    def needs_resampling(self) -> bool:\r\n-        \"\"\"Check if input data needs resampling for forecasting.\"\"\"\r\n-        return self.input_resolution_minutes != self.forecast_resolution_minutes\r\n-\r\n-    def get_resampling_factor(self) -> float:\r\n-        \"\"\"Get the factor by which to resample the data.\"\"\"\r\n-        return self.forecast_resolution_minutes / self.input_resolution_minutes\r\n-\r\n-    def get_interval_config(self) -> Optional[IntervalConfig]:\r\n-        \"\"\"Get the interval configuration.\"\"\"\r\n-        return self._interval_config\r\n-\r\n-    def to_dict(self) -> Dict[str, Any]:\r\n-        \"\"\"Convert config to dictionary.\"\"\"\r\n-        base_dict = {\r\n-            'model_type': self.model_type,\r\n-            'input_resolution_minutes': self.input_resolution_minutes,\r\n-            'forecast_resolution_minutes': self.forecast_resolution_minutes,\r\n-            'lookback_periods': self.lookback_periods,\r\n-            'forecast_periods': self.forecast_periods,\r\n-            'input_features': self.input_features,\r\n-            'output_features': self.output_features,\r\n-            'd_model': self.d_model,\r\n-            'n_heads': self.n_heads,\r\n-            'n_encoder_layers': self.n_encoder_layers,\r\n-            'n_decoder_layers': self.n_decoder_layers,\r\n-            'd_ff': self.d_ff,\r\n-            'dropout': self.dropout,\r\n-            'value_features': self.value_features,\r\n-            'time_features': self.time_features,\r\n-            'kernel_size': self.kernel_size,\r\n-            'batch_first': self.batch_first,\r\n-            'hidden_dims': self.hidden_dims,\r\n-            'activation': self.activation,\r\n-            'batch_size': self.batch_size,\r\n-            'learning_rate': self.learning_rate,\r\n-            'max_epochs': self.max_epochs,\r\n-            'optimizer': self.optimizer,\r\n-            'criterion': self.criterion,\r\n-            'device': self.device\r\n-        }\r\n-        \r\n-        # Add configuration dictionaries if they're not empty\r\n-        if self.optimizer_config:\r\n-            base_dict['optimizer_config'] = self.optimizer_config\r\n-        if self.scheduler_config:\r\n-            base_dict['scheduler_config'] = self.scheduler_config\r\n-        if self.criterion_config:\r\n-            base_dict['criterion_config'] = self.criterion_config\r\n-            \r\n-        return base_dict\r\n-\r\n-    @classmethod\r\n-    def get_default_config(\r\n-        cls,\r\n-        model_type: ModelType,  # Changed from str to ModelType\r\n-        input_resolution_minutes: int = 15,\r\n-        forecast_resolution_minutes: int = 15\r\n-    ) -> 'ModelConfig':\r\n-        \"\"\"Get default configuration for specified model type and resolutions.\r\n-        \r\n-        Args:\r\n-            model_type: Type of model to configure\r\n-            input_resolution_minutes: Resolution of input data in minutes\r\n-            forecast_resolution_minutes: Resolution of forecast in minutes\r\n-        \r\n-        Returns:\r\n-            ModelConfig with appropriate defaults for the specified model type and resolutions\r\n-        \"\"\"\r\n-        # Base configuration common to all models\r\n-        base_config = {\r\n-            'model_type': model_type,  # Pass ModelType enum directly\r\n-            'input_resolution_minutes': input_resolution_minutes,\r\n-            'forecast_resolution_minutes': forecast_resolution_minutes,\r\n-            'input_features': 1,\r\n-            'output_features': 1,\r\n-            'value_features': 1,\r\n-            'time_features': None  # Will be computed in post_init\r\n-        }\r\n-\r\n-        # Resolution-specific defaults\r\n-        if forecast_resolution_minutes <= 60:  # Sub-hourly or hourly predictions\r\n-            base_config.update({\r\n-                'lookback_periods': 24,  # 24 periods\r\n-                'forecast_periods': 12,  # 12 periods ahead\r\n-            })\r\n-        elif forecast_resolution_minutes <= 1440:  # Daily predictions\r\n-            base_config.update({\r\n-                'lookback_periods': 7,   # 7 days of history\r\n-                'forecast_periods': 5,   # 5 days ahead\r\n-            })\r\n-        else:  # Monthly predictions\r\n-            base_config.update({\r\n-                'lookback_periods': 12,  # 12 months of history\r\n-                'forecast_periods': 3,   # 3 months ahead\r\n-            })\r\n-\r\n-        # Model-specific configurations\r\n-        if model_type in {'vanilla_transformer', 'conv_transformer', 'informer', 'time_series_transformer'}:\r\n-            base_config.update({\r\n-                'd_model': 256,\r\n-                'n_heads': 8,\r\n-                'n_encoder_layers': 4,\r\n-                'n_decoder_layers': 4,\r\n-                'd_ff': 1024,\r\n-                'dropout': 0.2,\r\n-                'kernel_size': 3,\r\n-                'batch_first': True,\r\n-                \r\n-                # Training parameters optimized for time series\r\n-                'batch_size': 32,\r\n-                'learning_rate': 0.001,\r\n-                'max_epochs': 100,\r\n-                'optimizer': 'adamw',\r\n-                'optimizer_config': {\r\n-                    'weight_decay': 0.01,\r\n-                    'betas': (0.9, 0.98)\r\n-                },\r\n-                'scheduler': 'one_cycle',\r\n-                'scheduler_config': {\r\n-                    'pct_start': 0.3,\r\n-                    'div_factor': 25.0,\r\n-                    'final_div_factor': 1000.0\r\n-                }\r\n-            })\r\n-\r\n-            # Resolution-specific model adjustments\r\n-            if forecast_resolution_minutes <= 15:  # Fine-grained predictions\r\n-                base_config.update({\r\n-                    'd_model': 128,  # Smaller model for more frequent data\r\n-                    'n_heads': 4,\r\n-                    'dropout': 0.3,  # More dropout for regularization\r\n-                    'batch_size': 64  # Larger batches for more frequent data\r\n-                })\r\n-            elif forecast_resolution_minutes >= 1440:  # Daily or longer\r\n-                base_config.update({\r\n-                    'd_model': 512,  # Larger model for long-term patterns\r\n-                    'n_heads': 16,\r\n-                    'dropout': 0.1,  # Less dropout for sparse data\r\n-                    'batch_size': 16  # Smaller batches for less frequent data\r\n-                })\r\n-\r\n-        elif model_type == 'simple_neural_net':\r\n-            base_config.update({\r\n-                'hidden_dims': [64, 32],\r\n-                'activation': 'relu',\r\n-                'dropout': 0.1,\r\n-                'batch_size': 32,\r\n-                'learning_rate': 0.001\r\n-            })\r\n-\r\n-        elif model_type == 'linear_regression':\r\n-            base_config.update({\r\n-                'optimizer': 'adam',\r\n-                'learning_rate': 0.01,\r\n-                'batch_size': 64\r\n-            })\r\n-\r\n         return cls(**base_config)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733238244311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -224,11 +224,8 @@\n         base_config = {\r\n             'model_type': model_type,  # Pass ModelType enum directly\r\n             'input_resolution_minutes': input_resolution_minutes,\r\n             'forecast_resolution_minutes': forecast_resolution_minutes,\r\n-            'input_features': 1,\r\n-            'output_features': 1,\r\n-            'value_features': 1,\r\n             'time_features': None  # Will be computed in post_init\r\n         }\r\n \r\n         # Resolution-specific defaults\r\n"
                },
                {
                    "date": 1733238428650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,9 +207,10 @@\n     def get_default_config(\r\n         cls,\r\n         model_type: ModelType,  # Changed from str to ModelType\r\n         input_resolution_minutes: int = 15,\r\n-        forecast_resolution_minutes: int = 15\r\n+        forecast_resolution_minutes: int = 15,\r\n+        input_features: int = 7\r\n     ) -> 'ModelConfig':\r\n         \"\"\"Get default configuration for specified model type and resolutions.\r\n         \r\n         Args:\r\n"
                },
                {
                    "date": 1733238513730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -222,14 +222,17 @@\n             ModelConfig with appropriate defaults for the specified model type and resolutions\r\n         \"\"\"\r\n         # Base configuration common to all models\r\n         base_config = {\r\n-            'model_type': model_type,  # Pass ModelType enum directly\r\n+            'model_type': model_type,\r\n             'input_resolution_minutes': input_resolution_minutes,\r\n             'forecast_resolution_minutes': forecast_resolution_minutes,\r\n-            'time_features': None  # Will be computed in post_init\r\n+            'input_features': input_features,        # Ensure this is included\r\n+            'value_features': 1,                     # Single target value\r\n+            'time_features': input_features - 1,     # Remaining features are time features\r\n         }\r\n \r\n+\r\n         # Resolution-specific defaults\r\n         if forecast_resolution_minutes <= 60:  # Sub-hourly or hourly predictions\r\n             base_config.update({\r\n                 'lookback_periods': 24,  # 24 periods\r\n"
                }
            ],
            "date": 1733061971711,
            "name": "Commit-0",
            "content": "# models/config/model_config.py\r\nfrom dataclasses import dataclass, field\r\nfrom typing import Dict, Any, Optional, List\r\n\r\nfrom ..registry.model_types import ModelType\r\n\r\n@dataclass\r\nclass ModelConfig:\r\n    \"\"\"Configuration for model architecture.\"\"\"\r\n    model_type: ModelType\r\n    input_features: int\r\n    output_features: int = 1\r\n    d_model: int = 512\r\n    n_heads: int = 8\r\n    n_encoder_layers: int = 6\r\n    n_decoder_layers: int = 6\r\n    d_ff: int = 2048\r\n    dropout: float = 0.1\r\n    max_seq_length: int = 672  # Updated: 28 days * 24 hours * 4 intervals\r\n    transformer_labels_count: int = 48  # Updated: 12 hours * 4 intervals\r\n    points_per_interval: int = 4  # New field for 15-min intervals\r\n    \r\n    # Neural network specific\r\n    hidden_dims: List[int] = field(default_factory=lambda: [64, 32])\r\n    activation: str = 'relu'\r\n\r\n    # Training\r\n    batch_size: int = 32\r\n    learning_rate: float = 1e-3\r\n    max_epochs: int = 100\r\n    optimizer: str = 'adam'\r\n    optimizer_config: Dict[str, Any] = field(default_factory=dict)\r\n    scheduler: Optional[str] = None\r\n    scheduler_config: Dict[str, Any] = field(default_factory=dict)\r\n    criterion: str = 'mse'\r\n    criterion_config: Dict[str, Any] = field(default_factory=dict)\r\n\r\n    # Device\r\n    device: str = 'cuda'\r\n\r\n    def to_dict(self) -> Dict[str, Any]:\r\n        \"\"\"Convert config to dictionary.\"\"\"\r\n        return {k: v for k, v in self.__dict__.items() if v is not None}\r\n\r\ndef get_default_config(model_type: str) -> ModelConfig:\r\n    \"\"\"Get default configuration for specified model type.\"\"\"\r\n    base_config = {\r\n        'model_type': model_type,\r\n        'input_features': 1,\r\n        'output_dim': 1\r\n    }\r\n\r\n    if model_type in {'vanilla_transformer', 'conv_transformer', 'informer'}:\r\n        base_config.update({\r\n            'd_model': 512,\r\n            'n_heads': 8,\r\n            'n_encoder_layers': 3,\r\n            'n_decoder_layers': 3,\r\n            'd_ff': 2048,\r\n            'dropout': 0.1,\r\n        })\r\n\r\n    return ModelConfig(**base_config)"
        }
    ]
}